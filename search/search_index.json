{
    "docs": [
        {
            "location": "/",
            "text": "zend-http\n\n\n\n\n\n\nzend-http provides the HTTP message abstraction used by\n\nzend-mvc\n, and also provides an\nextensible, adapter-driven HTTP client library.\n\n\nThis library \ndoes not\n support \nPSR-7\n, as\nit predates that specification. For PSR-7 support, please see our\n\nDiactoros component\n.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-http/issues\n\n\nDocumentation is at https://docs.zendframework.com/zend-http/",
            "title": "zend-http"
        },
        {
            "location": "/#zend-http",
            "text": "zend-http provides the HTTP message abstraction used by zend-mvc , and also provides an\nextensible, adapter-driven HTTP client library.  This library  does not  support  PSR-7 , as\nit predates that specification. For PSR-7 support, please see our Diactoros component .   File issues at https://github.com/zendframework/zend-http/issues  Documentation is at https://docs.zendframework.com/zend-http/",
            "title": "zend-http"
        },
        {
            "location": "/intro/",
            "text": "Introduction\n\n\nzend-http provides the HTTP message abstraction used by\n\nzend-mvc\n, and also provides an\nextensible, adapter-driven HTTP client library. It provides the following\nabstractions:\n\n\n\n\nContext-less \nRequest\n and \nResponse\n classes that expose a fluent API for\n  introspecting several aspects of HTTP messages:\n\n\nRequest line information and response status information\n\n\nParameters, such as those found in POST and GET\n\n\nMessage Body\n\n\nHeaders\n\n\nA client implementation with various adapters that allow for sending requests\n  and introspecting responses.\n\n\n\n\n\n\nNot PSR-7!\n\n\nThis library \ndoes not\n support \nPSR-7\n, as\nit predates that specification. For PSR-7 support, please see our\n\nDiactoros component\n.\n\n\n\n\nZend\\Http Request, Response and Headers\n\n\nThe request, response and headers implementations of the zend-http component\nprovides a fluent, object-oriented interface for introspecting information from\nall the various parts of an HTTP request or HTTP response. The primary classes\nare \nZend\\Http\\Request\n and \nZend\\Http\\Response\n. Both are \u201ccontext-less\u201d,\nmeaning that they model a request or response in the same way whether it is\npresented by a client (to \nsend\n a request and \nreceive\n a response) or by a\nserver (to \nreceive\n a request and \nsend\n a response). In other words,\nregardless of the context, the API remains the same for introspecting their\nvarious respective parts. Each attempts to fully model a request or response so\nthat a developer can create these objects from a factory, or create and populate\nthem manually.",
            "title": "Intro"
        },
        {
            "location": "/intro/#introduction",
            "text": "zend-http provides the HTTP message abstraction used by zend-mvc , and also provides an\nextensible, adapter-driven HTTP client library. It provides the following\nabstractions:   Context-less  Request  and  Response  classes that expose a fluent API for\n  introspecting several aspects of HTTP messages:  Request line information and response status information  Parameters, such as those found in POST and GET  Message Body  Headers  A client implementation with various adapters that allow for sending requests\n  and introspecting responses.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#not-psr-7",
            "text": "This library  does not  support  PSR-7 , as\nit predates that specification. For PSR-7 support, please see our Diactoros component .",
            "title": "Not PSR-7!"
        },
        {
            "location": "/intro/#zendhttp-request-response-and-headers",
            "text": "The request, response and headers implementations of the zend-http component\nprovides a fluent, object-oriented interface for introspecting information from\nall the various parts of an HTTP request or HTTP response. The primary classes\nare  Zend\\Http\\Request  and  Zend\\Http\\Response . Both are \u201ccontext-less\u201d,\nmeaning that they model a request or response in the same way whether it is\npresented by a client (to  send  a request and  receive  a response) or by a\nserver (to  receive  a request and  send  a response). In other words,\nregardless of the context, the API remains the same for introspecting their\nvarious respective parts. Each attempts to fully model a request or response so\nthat a developer can create these objects from a factory, or create and populate\nthem manually.",
            "title": "Zend\\Http Request, Response and Headers"
        },
        {
            "location": "/request/",
            "text": "The Request Class\n\n\nZend\\Http\\Request\n is responsible for providing a fluent API that allows a\ndeveloper to interact with all the various parts of an HTTP request.\n\n\nA typical HTTP request looks like this:\n\n\n| METHOD | URI | VERSION |\n|        HEADERS         |\n|         BODY           |\n\n\n\nIn simplified terms, the request consists of a method, URI, and HTTP version\nnumber; together, they make up the \"Request Line.\" This line is followed by zero\nor more HTTP headers, which is followed by an empty line and then the request\nbody; the body is typically used when a client wishes to send data \u2014 which\ncould be urlencoded parameters, a JSON document, an XML document, or even one or\nmore files \u2014 to the server.  More information on the structure and\nspecification of a HTTP request can be found in\n\nRFC-2616 on the W3.org site\n.\n\n\nQuick Start\n\n\nRequest objects can either be created from the provided \nfromString()\n factory,\nor, if you wish to have a completely empty object to start with, by\nmanually instantiating the \nZend\\Http\\Request\n class with no parameters.\n\n\nuse Zend\\Http\\Request;\n\n$request = Request::fromString(<<<EOS\nPOST /foo HTTP/1.1\nHeaderField1: header-field-value1\nHeaderField2: header-field-value2\n\nfoo=bar\nEOS\n);\n\n// OR, the completely equivalent\n\n$request = new Request();\n$request->setMethod(Request::METHOD_POST);\n$request->setUri('/foo');\n$request->getHeaders()->addHeaders([\n    'HeaderField1' => 'header-field-value1',\n    'HeaderField2' => 'header-field-value2',\n]);\n$request->getPost()->set('foo', 'bar');\n\n\n\nConfiguration Options\n\n\nNo configuration options are available.\n\n\nAvailable Methods\n\n\nThe following table details available methods, their signatures, and a brief\ndescription. Note that the following references refer to the following\nfully qualified class names and/or namespaces:\n\n\n\n\nHeaderInterface\n: \nZend\\Http\\Header\\HeaderInterface\n\n\nHeaders\n: \nZend\\Http\\Headers\n\n\nHeader\n: \nZend\\Http\\Header\n\n\nParameters\n: \nZend\\Stdlib\\ParametersInterface\n\n\nRequest\n: \nZend\\Http\\Request\n\n\nUri\n: \nZend\\Uri\\Http\n\n\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstatic fromString(string $string) : Request\n\n\nA factory that produces a \nRequest\n object from a well-formed HTTP request message string.\n\n\n\n\n\n\nsetMethod(string $method) : self\n\n\nSet the method for this request.\n\n\n\n\n\n\ngetMethod() : string\n\n\nReturn the method for this request.\n\n\n\n\n\n\nsetUri(string|Uri $uri) : self\n\n\nSet the URI/URL for this request; this can be a string or an instance of \nZend\\Uri\\Http\n.\n\n\n\n\n\n\ngetUri() : Uri\n\n\nReturn the URI for this request object.\n\n\n\n\n\n\ngetUriString() : string\n\n\nReturn the URI for this request object as a string.\n\n\n\n\n\n\nsetVersion(string $version) : self\n\n\nSet the HTTP version for this object, one of 1.0 or 1.1 (\nRequest::VERSION_10\n, \nRequest::VERSION_11\n).\n\n\n\n\n\n\ngetVersion() : string\n\n\nReturn the HTTP version for this request.\n\n\n\n\n\n\nsetQuery(Parameters $query) : self\n\n\nProvide an alternate Parameter Container implementation for query parameters in this object. (This is NOT the primary API for value setting; for that, see \ngetQuery()\n).\n\n\n\n\n\n\ngetQuery(string|null $name, mixed|null $default) : null|string|Parameters\n\n\nReturn the parameter container responsible for query parameters or a single query parameter based on \n$name\n.\n\n\n\n\n\n\nsetPost(Parameters $post) : self\n\n\nProvide an alternate Parameter Container implementation for POST parameters in this object. (This is NOT the primary API for value setting; for that, see \ngetPost()\n).\n\n\n\n\n\n\ngetPost(string|null $name, mixed|null $default) : null|string|Parameters\n\n\nReturn the parameter container responsible for POST parameters or a single POST parameter, based on \n$name\n.\n\n\n\n\n\n\ngetCookie() : Header\\Cookie\n\n\nReturn the Cookie header, this is the same as calling \n$request->getHeaders()->get('Cookie');\n.\n\n\n\n\n\n\nsetFiles(Parameters $files) : self\n\n\nProvide an alternate Parameter Container implementation for file parameters in this object, (This is NOT the primary API for value setting; for that, see \ngetFiles()\n).\n\n\n\n\n\n\ngetFiles(string|null $name, mixed|null $default) : null|string|Parameters\n\n\nReturn the parameter container responsible for file parameters or a single file parameter, based on \n$name\n.\n\n\n\n\n\n\nsetHeaders(Headers $headers) : self\n\n\nProvide an alternate Parameter Container implementation for headers in this object, (this is NOT the primary API for value setting, for that see \ngetHeaders()\n).\n\n\n\n\n\n\ngetHeaders(string|null $name, mixed|null $default) : mixed\n\n\nReturn the container responsible for storing HTTP headers. This container exposes the primary API for manipulating headers set in the HTTP request. See the section on \nHeaders\n for more information. Return value is based on \n$name\n; \nnull\n returns \nHeaders\n, while a matched header returns a \nHeader\\HeaderInterface\n implementation for single-value headers or an \nArrayIterator\n for multi-value headers.\n\n\n\n\n\n\nsetMetadata(string|int|array|Traversable $spec, mixed $value) : self\n\n\nSet message metadata.  Non-destructive setting of message metadata; always adds to the metadata, never overwrites the entire metadata container.\n\n\n\n\n\n\ngetMetadata(null|string|int $key, null|mixed $default) : mixed\n\n\nRetrieve all metadata or a single metadatum as specified by key.\n\n\n\n\n\n\nsetContent(mixed $value) : self\n\n\nSet request body (content).\n\n\n\n\n\n\ngetContent() : mixed\n\n\nGet request body (content).\n\n\n\n\n\n\nisOptions() : bool\n\n\nIs this an OPTIONS method request?\n\n\n\n\n\n\nisGet() : bool\n\n\nIs this a GET method request?\n\n\n\n\n\n\nisHead() : bool\n\n\nIs this a HEAD method request?\n\n\n\n\n\n\nisPost() : bool\n\n\nIs this a POST method request?\n\n\n\n\n\n\nisPut() : bool\n\n\nIs this a PUT method request?\n\n\n\n\n\n\nisDelete() : bool\n\n\nIs this a DELETE method request?\n\n\n\n\n\n\nisTrace() : bool\n\n\nIs this a TRACE method request?\n\n\n\n\n\n\nisConnect() : bool\n\n\nIs this a CONNECT method request?\n\n\n\n\n\n\nisPatch() : bool\n\n\nIs this a PATCH method request?\n\n\n\n\n\n\nisXmlHttpRequest() : bool\n\n\nIs this a Javascript XMLHttpRequest?\n\n\n\n\n\n\nisFlashRequest() : bool\n\n\nIs this a Flash request?\n\n\n\n\n\n\nrenderRequestLine() : string\n\n\nReturn the formatted request line (first line) for this HTTP request.\n\n\n\n\n\n\ntoString() : string\n\n\nReturns string\n\n\n\n\n\n\n__toString() : string\n\n\nAllow PHP casting of this object.\n\n\n\n\n\n\n\n\nExamples\n\n\nGenerating a Request object from a string\n\n\nuse Zend\\Http\\Request;\n\n$string = \"GET /foo HTTP/1.1\\r\\n\\r\\nSome Content\";\n$request = Request::fromString($string);\n\n$request->getMethod();    // returns Request::METHOD_GET\n$request->getUri();       // returns Zend\\Uri\\Http object\n$request->getUriString(); // returns '/foo'\n$request->getVersion();   // returns Request::VERSION_11 or '1.1'\n$request->getContent();   // returns 'Some Content'\n\n\n\nRetrieving and setting headers\n\n\nuse Zend\\Http\\Request;\nuse Zend\\Http\\Header\\Cookie;\n\n$request = new Request();\n$request->getHeaders()->get('Content-Type'); // return content type\n$request->getHeaders()->addHeader(new Cookie(['foo' => 'bar']));\nforeach ($request->getHeaders() as $header) {\n    printf(\"%s with value %s\\n\", $header->getFieldName(), $header->getFieldValue());\n}\n\n\n\nRetrieving and setting GET and POST values\n\n\nuse Zend\\Http\\Request;\n\n$request = new Request();\n\n// getPost() and getQuery() both return, by default, a Parameters object, which\n// extends ArrayObject\n$request->getPost()->foo = 'Foo value';\n$request->getQuery()->bar = 'Bar value';\n$request->getPost('foo'); // returns 'Foo value'\n$request->getQuery()->offsetGet('bar'); // returns 'Bar value'\n\n\n\nGenerating a formatted HTTP Request from a Request object\n\n\nuse Zend\\Http\\Request;\n\n$request = new Request();\n$request->setMethod(Request::METHOD_POST);\n$request->setUri('/foo');\n$request->getHeaders()->addHeaders([\n    'HeaderField1' => 'header-field-value1',\n    'HeaderField2' => 'header-field-value2',\n]);\n$request->getPost()->set('foo', 'bar');\n$request->setContent($request->getPost()->toString());\necho $request->toString();\n\n/** Will produce:\nPOST /foo HTTP/1.1\nHeaderField1: header-field-value1\nHeaderField2: header-field-value2\n\nfoo=bar\n*/",
            "title": "Request"
        },
        {
            "location": "/request/#the-request-class",
            "text": "Zend\\Http\\Request  is responsible for providing a fluent API that allows a\ndeveloper to interact with all the various parts of an HTTP request.  A typical HTTP request looks like this:  | METHOD | URI | VERSION |\n|        HEADERS         |\n|         BODY           |  In simplified terms, the request consists of a method, URI, and HTTP version\nnumber; together, they make up the \"Request Line.\" This line is followed by zero\nor more HTTP headers, which is followed by an empty line and then the request\nbody; the body is typically used when a client wishes to send data \u2014 which\ncould be urlencoded parameters, a JSON document, an XML document, or even one or\nmore files \u2014 to the server.  More information on the structure and\nspecification of a HTTP request can be found in RFC-2616 on the W3.org site .",
            "title": "The Request Class"
        },
        {
            "location": "/request/#quick-start",
            "text": "Request objects can either be created from the provided  fromString()  factory,\nor, if you wish to have a completely empty object to start with, by\nmanually instantiating the  Zend\\Http\\Request  class with no parameters.  use Zend\\Http\\Request;\n\n$request = Request::fromString(<<<EOS\nPOST /foo HTTP/1.1\nHeaderField1: header-field-value1\nHeaderField2: header-field-value2\n\nfoo=bar\nEOS\n);\n\n// OR, the completely equivalent\n\n$request = new Request();\n$request->setMethod(Request::METHOD_POST);\n$request->setUri('/foo');\n$request->getHeaders()->addHeaders([\n    'HeaderField1' => 'header-field-value1',\n    'HeaderField2' => 'header-field-value2',\n]);\n$request->getPost()->set('foo', 'bar');",
            "title": "Quick Start"
        },
        {
            "location": "/request/#configuration-options",
            "text": "No configuration options are available.",
            "title": "Configuration Options"
        },
        {
            "location": "/request/#available-methods",
            "text": "The following table details available methods, their signatures, and a brief\ndescription. Note that the following references refer to the following\nfully qualified class names and/or namespaces:   HeaderInterface :  Zend\\Http\\Header\\HeaderInterface  Headers :  Zend\\Http\\Headers  Header :  Zend\\Http\\Header  Parameters :  Zend\\Stdlib\\ParametersInterface  Request :  Zend\\Http\\Request  Uri :  Zend\\Uri\\Http      Method signature  Description      static fromString(string $string) : Request  A factory that produces a  Request  object from a well-formed HTTP request message string.    setMethod(string $method) : self  Set the method for this request.    getMethod() : string  Return the method for this request.    setUri(string|Uri $uri) : self  Set the URI/URL for this request; this can be a string or an instance of  Zend\\Uri\\Http .    getUri() : Uri  Return the URI for this request object.    getUriString() : string  Return the URI for this request object as a string.    setVersion(string $version) : self  Set the HTTP version for this object, one of 1.0 or 1.1 ( Request::VERSION_10 ,  Request::VERSION_11 ).    getVersion() : string  Return the HTTP version for this request.    setQuery(Parameters $query) : self  Provide an alternate Parameter Container implementation for query parameters in this object. (This is NOT the primary API for value setting; for that, see  getQuery() ).    getQuery(string|null $name, mixed|null $default) : null|string|Parameters  Return the parameter container responsible for query parameters or a single query parameter based on  $name .    setPost(Parameters $post) : self  Provide an alternate Parameter Container implementation for POST parameters in this object. (This is NOT the primary API for value setting; for that, see  getPost() ).    getPost(string|null $name, mixed|null $default) : null|string|Parameters  Return the parameter container responsible for POST parameters or a single POST parameter, based on  $name .    getCookie() : Header\\Cookie  Return the Cookie header, this is the same as calling  $request->getHeaders()->get('Cookie'); .    setFiles(Parameters $files) : self  Provide an alternate Parameter Container implementation for file parameters in this object, (This is NOT the primary API for value setting; for that, see  getFiles() ).    getFiles(string|null $name, mixed|null $default) : null|string|Parameters  Return the parameter container responsible for file parameters or a single file parameter, based on  $name .    setHeaders(Headers $headers) : self  Provide an alternate Parameter Container implementation for headers in this object, (this is NOT the primary API for value setting, for that see  getHeaders() ).    getHeaders(string|null $name, mixed|null $default) : mixed  Return the container responsible for storing HTTP headers. This container exposes the primary API for manipulating headers set in the HTTP request. See the section on  Headers  for more information. Return value is based on  $name ;  null  returns  Headers , while a matched header returns a  Header\\HeaderInterface  implementation for single-value headers or an  ArrayIterator  for multi-value headers.    setMetadata(string|int|array|Traversable $spec, mixed $value) : self  Set message metadata.  Non-destructive setting of message metadata; always adds to the metadata, never overwrites the entire metadata container.    getMetadata(null|string|int $key, null|mixed $default) : mixed  Retrieve all metadata or a single metadatum as specified by key.    setContent(mixed $value) : self  Set request body (content).    getContent() : mixed  Get request body (content).    isOptions() : bool  Is this an OPTIONS method request?    isGet() : bool  Is this a GET method request?    isHead() : bool  Is this a HEAD method request?    isPost() : bool  Is this a POST method request?    isPut() : bool  Is this a PUT method request?    isDelete() : bool  Is this a DELETE method request?    isTrace() : bool  Is this a TRACE method request?    isConnect() : bool  Is this a CONNECT method request?    isPatch() : bool  Is this a PATCH method request?    isXmlHttpRequest() : bool  Is this a Javascript XMLHttpRequest?    isFlashRequest() : bool  Is this a Flash request?    renderRequestLine() : string  Return the formatted request line (first line) for this HTTP request.    toString() : string  Returns string    __toString() : string  Allow PHP casting of this object.",
            "title": "Available Methods"
        },
        {
            "location": "/request/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/request/#generating-a-request-object-from-a-string",
            "text": "use Zend\\Http\\Request;\n\n$string = \"GET /foo HTTP/1.1\\r\\n\\r\\nSome Content\";\n$request = Request::fromString($string);\n\n$request->getMethod();    // returns Request::METHOD_GET\n$request->getUri();       // returns Zend\\Uri\\Http object\n$request->getUriString(); // returns '/foo'\n$request->getVersion();   // returns Request::VERSION_11 or '1.1'\n$request->getContent();   // returns 'Some Content'",
            "title": "Generating a Request object from a string"
        },
        {
            "location": "/request/#retrieving-and-setting-headers",
            "text": "use Zend\\Http\\Request;\nuse Zend\\Http\\Header\\Cookie;\n\n$request = new Request();\n$request->getHeaders()->get('Content-Type'); // return content type\n$request->getHeaders()->addHeader(new Cookie(['foo' => 'bar']));\nforeach ($request->getHeaders() as $header) {\n    printf(\"%s with value %s\\n\", $header->getFieldName(), $header->getFieldValue());\n}",
            "title": "Retrieving and setting headers"
        },
        {
            "location": "/request/#retrieving-and-setting-get-and-post-values",
            "text": "use Zend\\Http\\Request;\n\n$request = new Request();\n\n// getPost() and getQuery() both return, by default, a Parameters object, which\n// extends ArrayObject\n$request->getPost()->foo = 'Foo value';\n$request->getQuery()->bar = 'Bar value';\n$request->getPost('foo'); // returns 'Foo value'\n$request->getQuery()->offsetGet('bar'); // returns 'Bar value'",
            "title": "Retrieving and setting GET and POST values"
        },
        {
            "location": "/request/#generating-a-formatted-http-request-from-a-request-object",
            "text": "use Zend\\Http\\Request;\n\n$request = new Request();\n$request->setMethod(Request::METHOD_POST);\n$request->setUri('/foo');\n$request->getHeaders()->addHeaders([\n    'HeaderField1' => 'header-field-value1',\n    'HeaderField2' => 'header-field-value2',\n]);\n$request->getPost()->set('foo', 'bar');\n$request->setContent($request->getPost()->toString());\necho $request->toString();\n\n/** Will produce:\nPOST /foo HTTP/1.1\nHeaderField1: header-field-value1\nHeaderField2: header-field-value2\n\nfoo=bar\n*/",
            "title": "Generating a formatted HTTP Request from a Request object"
        },
        {
            "location": "/response/",
            "text": "The Response Class\n\n\nZend\\Http\\Response\n is responsible for providing a fluent API that allows a\ndeveloper to interact with all the various parts of an HTTP response.\n\n\nA typical HTTP Response looks like this:\n\n\n| VERSION | CODE | REASON |\n|        HEADERS          |\n|         BODY            |\n\n\n\nThe first line of the response consists of the HTTP version, status code, and\nthe reason string for the provided status code; this is called the Response\nLine. Next is a set of zero or more headers.  The remainder of the response is\nthe response body, which is typically a string of HTML that will render on the\nclient's browser, but which can also be a place for request/response payload\ndata typical of an AJAX request. More information on the structure and\nspecification of an HTTP response can be found in\n\nRFC-2616 on the W3.org site\n.\n\n\nQuick Start\n\n\nResponse objects can either be created from the provided \nfromString()\n factory,\nor, if you wish to have a completely empty object to start with, by\ninstantiating the \nZend\\Http\\Response\n class with no arguments.\n\n\nuse Zend\\Http\\Response;\n$response = Response::fromString(<<<EOS\nHTTP/1.0 200 OK\nHeaderField1: header-field-value\nHeaderField2: header-field-value2\n\n<html>\n<body>\n    Hello World\n</body>\n</html>\nEOS);\n\n// OR\n\n$response = new Response();\n$response->setStatusCode(Response::STATUS_CODE_200);\n$response->getHeaders()->addHeaders([\n    'HeaderField1' => 'header-field-value',\n    'HeaderField2' => 'header-field-value2',\n]);\n$response->setContent(<<<EOS\n<html>\n<body>\n    Hello World\n</body>\n</html>\nEOS\n);\n\n\n\nConfiguration Options\n\n\nNo configuration options are available.\n\n\nAvailable Methods\n\n\nThe following table details available methods, their signatures, and a brief\ndescription. Note that the following references refer to the following\nfully qualified class names and/or namespaces:\n\n\n\n\nHeaders\n: \nZend\\Http\\Headers\n\n\nResponse\n: \nZend\\Http\\Response\n\n\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstatic fromString(string $string) : Response\n\n\nPopulate object from string.\n\n\n\n\n\n\nrenderStatusLine() : string\n\n\nRender the status line header\n\n\n\n\n\n\nsetHeaders(Headers $headers) : self\n\n\nProvide an alternate Parameter Container implementation for headers in this object. (This is NOT the primary API for value setting; for that, see \ngetHeaders()\n.)\n\n\n\n\n\n\ngetHeaders() : Headers\n\n\nReturn the container responsible for storing HTTP headers. This container exposes the primary API for manipulating headers set in the HTTP response. See the section on \nHeaders\n for more information.\n\n\n\n\n\n\nsetVersion(string $version) : self\n\n\nSet the HTTP version for this object, one of 1.0 or 1.1 (\nRequest::VERSION_10\n, \nRequest::VERSION_11\n).\n\n\n\n\n\n\ngetVersion() : string\n\n\nReturn the HTTP version for this request.\n\n\n\n\n\n\nsetStatusCode(int $code) : self\n\n\nSet HTTP status code.\n\n\n\n\n\n\ngetStatusCode() : int\n\n\nRetrieve HTTP status code.\n\n\n\n\n\n\nsetReasonPhrase(string $reasonPhrase) : self\n\n\nSet custom HTTP status message.\n\n\n\n\n\n\ngetReasonPhrase() : string\n\n\nGet HTTP status message.\n\n\n\n\n\n\nisClientError() : bool\n\n\nDoes the status code indicate a client error?\n\n\n\n\n\n\nisForbidden() : bool\n\n\nIs the request forbidden due to ACLs?\n\n\n\n\n\n\nisInformational() : bool\n\n\nIs the current status \"informational\"?\n\n\n\n\n\n\nisNotFound() : bool\n\n\nDoes the status code indicate the resource is not found?\n\n\n\n\n\n\nisOk() : bool\n\n\nDo we have a normal, OK response?\n\n\n\n\n\n\nisServerError() : bool\n\n\nDoes the status code reflect a server error?\n\n\n\n\n\n\nisRedirect() : bool\n\n\nDo we have a redirect?\n\n\n\n\n\n\nisSuccess() : bool\n\n\nWas the response successful?\n\n\n\n\n\n\ndecodeChunkedBody(string $body) : string\n\n\nDecode a \"chunked\" transfer-encoded body and return the decoded text.\n\n\n\n\n\n\ndecodeGzip(string $body) : string\n\n\nDecode a gzip encoded message (when \nContent-Encoding\n indicates gzip). Currently requires PHP with zlib support.\n\n\n\n\n\n\ndecodeDeflate(string $body) : string\n\n\nDecode a zlib deflated message (when \nContent-Encoding\n indicates deflate). Currently requires PHP with zlib support.\n\n\n\n\n\n\nsetMetadata(string|int|array|Traversable $spec, mixed $value) : self\n\n\nNon-destructive setting of message metadata; always adds to the metadata, never overwrites the entire metadata container.\n\n\n\n\n\n\ngetMetadata(null|string|int $key, null|mixed $default) : mixed\n\n\nRetrieve all metadata or a single metadatum as specified by key.\n\n\n\n\n\n\nsetContent(mixed $value) : self\n\n\nSet message content.\n\n\n\n\n\n\ngetContent() : mixed\n\n\nGet raw message content.\n\n\n\n\n\n\ngetBody() : mixed\n\n\nGet decoded message content.\n\n\n\n\n\n\ntoString() : string\n\n\nReturns string representation of response.\n\n\n\n\n\n\n\n\nExamples\n\n\nGenerating a Response object from a string\n\n\nuse Zend\\Http\\Response;\n$request = Response::fromString(<<<EOS\nHTTP/1.0 200 OK\nHeaderField1: header-field-value\nHeaderField2: header-field-value2\n\n<html>\n<body>\n    Hello World\n</body>\n</html>\nEOS);\n\n\n\nGenerating a formatted HTTP Response from a Response object\n\n\nuse Zend\\Http\\Response;\n$response = new Response();\n$response->setStatusCode(Response::STATUS_CODE_200);\n$response->getHeaders()->addHeaders([\n    'HeaderField1' => 'header-field-value',\n    'HeaderField2' => 'header-field-value2',\n]);\n$response->setContent(<<<EOS\n<html>\n<body>\n    Hello World\n</body>\n</html>\nEOS);",
            "title": "Response"
        },
        {
            "location": "/response/#the-response-class",
            "text": "Zend\\Http\\Response  is responsible for providing a fluent API that allows a\ndeveloper to interact with all the various parts of an HTTP response.  A typical HTTP Response looks like this:  | VERSION | CODE | REASON |\n|        HEADERS          |\n|         BODY            |  The first line of the response consists of the HTTP version, status code, and\nthe reason string for the provided status code; this is called the Response\nLine. Next is a set of zero or more headers.  The remainder of the response is\nthe response body, which is typically a string of HTML that will render on the\nclient's browser, but which can also be a place for request/response payload\ndata typical of an AJAX request. More information on the structure and\nspecification of an HTTP response can be found in RFC-2616 on the W3.org site .",
            "title": "The Response Class"
        },
        {
            "location": "/response/#quick-start",
            "text": "Response objects can either be created from the provided  fromString()  factory,\nor, if you wish to have a completely empty object to start with, by\ninstantiating the  Zend\\Http\\Response  class with no arguments.  use Zend\\Http\\Response;\n$response = Response::fromString(<<<EOS\nHTTP/1.0 200 OK\nHeaderField1: header-field-value\nHeaderField2: header-field-value2\n\n<html>\n<body>\n    Hello World\n</body>\n</html>\nEOS);\n\n// OR\n\n$response = new Response();\n$response->setStatusCode(Response::STATUS_CODE_200);\n$response->getHeaders()->addHeaders([\n    'HeaderField1' => 'header-field-value',\n    'HeaderField2' => 'header-field-value2',\n]);\n$response->setContent(<<<EOS\n<html>\n<body>\n    Hello World\n</body>\n</html>\nEOS\n);",
            "title": "Quick Start"
        },
        {
            "location": "/response/#configuration-options",
            "text": "No configuration options are available.",
            "title": "Configuration Options"
        },
        {
            "location": "/response/#available-methods",
            "text": "The following table details available methods, their signatures, and a brief\ndescription. Note that the following references refer to the following\nfully qualified class names and/or namespaces:   Headers :  Zend\\Http\\Headers  Response :  Zend\\Http\\Response      Method signature  Description      static fromString(string $string) : Response  Populate object from string.    renderStatusLine() : string  Render the status line header    setHeaders(Headers $headers) : self  Provide an alternate Parameter Container implementation for headers in this object. (This is NOT the primary API for value setting; for that, see  getHeaders() .)    getHeaders() : Headers  Return the container responsible for storing HTTP headers. This container exposes the primary API for manipulating headers set in the HTTP response. See the section on  Headers  for more information.    setVersion(string $version) : self  Set the HTTP version for this object, one of 1.0 or 1.1 ( Request::VERSION_10 ,  Request::VERSION_11 ).    getVersion() : string  Return the HTTP version for this request.    setStatusCode(int $code) : self  Set HTTP status code.    getStatusCode() : int  Retrieve HTTP status code.    setReasonPhrase(string $reasonPhrase) : self  Set custom HTTP status message.    getReasonPhrase() : string  Get HTTP status message.    isClientError() : bool  Does the status code indicate a client error?    isForbidden() : bool  Is the request forbidden due to ACLs?    isInformational() : bool  Is the current status \"informational\"?    isNotFound() : bool  Does the status code indicate the resource is not found?    isOk() : bool  Do we have a normal, OK response?    isServerError() : bool  Does the status code reflect a server error?    isRedirect() : bool  Do we have a redirect?    isSuccess() : bool  Was the response successful?    decodeChunkedBody(string $body) : string  Decode a \"chunked\" transfer-encoded body and return the decoded text.    decodeGzip(string $body) : string  Decode a gzip encoded message (when  Content-Encoding  indicates gzip). Currently requires PHP with zlib support.    decodeDeflate(string $body) : string  Decode a zlib deflated message (when  Content-Encoding  indicates deflate). Currently requires PHP with zlib support.    setMetadata(string|int|array|Traversable $spec, mixed $value) : self  Non-destructive setting of message metadata; always adds to the metadata, never overwrites the entire metadata container.    getMetadata(null|string|int $key, null|mixed $default) : mixed  Retrieve all metadata or a single metadatum as specified by key.    setContent(mixed $value) : self  Set message content.    getContent() : mixed  Get raw message content.    getBody() : mixed  Get decoded message content.    toString() : string  Returns string representation of response.",
            "title": "Available Methods"
        },
        {
            "location": "/response/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/response/#generating-a-response-object-from-a-string",
            "text": "use Zend\\Http\\Response;\n$request = Response::fromString(<<<EOS\nHTTP/1.0 200 OK\nHeaderField1: header-field-value\nHeaderField2: header-field-value2\n\n<html>\n<body>\n    Hello World\n</body>\n</html>\nEOS);",
            "title": "Generating a Response object from a string"
        },
        {
            "location": "/response/#generating-a-formatted-http-response-from-a-response-object",
            "text": "use Zend\\Http\\Response;\n$response = new Response();\n$response->setStatusCode(Response::STATUS_CODE_200);\n$response->getHeaders()->addHeaders([\n    'HeaderField1' => 'header-field-value',\n    'HeaderField2' => 'header-field-value2',\n]);\n$response->setContent(<<<EOS\n<html>\n<body>\n    Hello World\n</body>\n</html>\nEOS);",
            "title": "Generating a formatted HTTP Response from a Response object"
        },
        {
            "location": "/headers/",
            "text": "Headers\n\n\nZend\\Http\\Headers\n is a container for HTTP headers. It is typically accessed as\npart of a \nZend\\Http\\Request\n or \nZend\\Http\\Response\n instance, via a\n\ngetHeaders()\n call. The \nHeaders\n container will lazily load actual\n\nZend\\Http\\Header\\HeaderInterface\n instances as to reduce the overhead of header\nspecific parsing.\n\n\nThe class under the \nZend\\Http\\Header\n namespace are the domain specific\nimplementations for the various types of headers that one might encounter during\nthe typical HTTP request. If a header of unknown type is encountered, it will be\nimplemented as a \nZend\\Http\\Header\\GenericHeader\n instance. See the below table\nfor a list of the various HTTP headers and the API that is specific to each\nheader type.\n\n\nQuick Start\n\n\nThe quickest way to get started interacting with header objects is by retrieving\nan already populated \nHeaders\n container from a request or response instance.\n\n\n// $client is an instance of Zend\\Http\\Client\n\n// You can retrieve the request headers by first retrieving\n// the Request object and then calling getHeaders on it\n$requestHeaders  = $client->getRequest()->getHeaders();\n\n// The same method also works for retrieving Response headers\n$responseHeaders = $client->getResponse()->getHeaders();\n\n\n\nZend\\Http\\Headers\n can also extract headers from a string:\n\n\nuse Zend\\Http\\Headers;\n\n$headerString = <<<EOB\nHost: www.example.com\nContent-Type: text/html\nContent-Length: 1337\nEOB;\n\n$headers = Headers::fromString($headerString);\n// $headers is now populated with three objects\n//   (1) Zend\\Http\\Header\\Host\n//   (2) Zend\\Http\\Header\\ContentType\n//   (3) Zend\\Http\\Header\\ContentLength\n\n\n\nNow that you have an instance of \nZend\\Http\\Headers\n, you can manipulate the\nindividual headers it contains using the provided public API methods outlined in\nthe \nAvailable Methods\n section.\n\n\nConfiguration Options\n\n\nNo configuration options are available.\n\n\nAvailable Methods\n\n\nThe following is a list of methods available to \nZend\\Http\\Headers\n. For\nbrevity, we map the following references to the following classes or namespaces:\n\n\n\n\nHeaderInterface\n: \nZend\\Http\\Header\\HeaderInterface\n\n\nHeaders\n: \nZend\\Http\\Headers\n\n\nPluginClassLocator\n: \nZend\\Loader\\PluginClassLocator\n\n\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstatic fromString(string $string) : Headers\n\n\nParses a string for headers, and aggregates them, in order, a new \nHeaders\n instance, primarily as strings until they are needed (they will be lazy loaded).\n\n\n\n\n\n\nsetPluginClassLoader(PluginClassLocator $pluginClassLoader) : self\n\n\nSet an alternate implementation for the plugin class loader.\n\n\n\n\n\n\ngetPluginClassLoader() : PluginClassLocator\n\n\nReturn an instance of a \nPluginClassLocator\n; lazy-load and inject map if necessary.\n\n\n\n\n\n\naddHeaders(array|Traversable $headers) : self\n\n\nAdd many headers at once; expects an array (or \nTraversable\n object) of type/value pairs.\n\n\n\n\n\n\naddHeaderLine(string $headerFieldNameOrLine, string $fieldValue) : self\n\n\nAdd a raw header line, either as separate name and value arguments, or as a single string in the form \nname: value\n This method allows for lazy-loading in that the parsing and instantiation of a \nHeaderInterface\n implementation will be delayed until they are retrieved by either \nget()\n or \ncurrent()\n.\n\n\n\n\n\n\naddHeader(HeaderInterface $header) : self\n\n\nAdd a header instance to the container; for raw values see \naddHeaderLine()\n and \naddHeaders()\n.\n\n\n\n\n\n\nremoveHeader(HeaderInterface $header) : bool\n\n\nRemove a Header from the container.\n\n\n\n\n\n\nclearHeaders() : self\n\n\nRemoves all headers from the container.\n\n\n\n\n\n\nget(string $name) : false|HeaderInterface|ArrayIterator\n\n\nGet all values for a given header. If none are found, \nfalse\n is returned. If the header is a single-value header, a \nHeaderInterface\n is returned. If the header is a multi-value header, an \nArrayIterator\n containing all values is returned.\n\n\n\n\n\n\nhas(string $name) : bool\n\n\nTest for existence of a header.\n\n\n\n\n\n\nnext() : void\n\n\nAdvance the pointer for this object as an iterator.\n\n\n\n\n\n\nkey() : mixed\n\n\nReturn the current key for this object as an iterator.\n\n\n\n\n\n\nvalid() : bool\n\n\nIs this iterator still valid?\n\n\n\n\n\n\nrewind() : void\n\n\nReset the internal pointer for this object as an iterator.\n\n\n\n\n\n\ncurrent() : HeaderInterface\n\n\nReturn the current value for this iterator, lazy loading it if need be.\n\n\n\n\n\n\ncount() : int\n\n\nReturn the number of headers in this container. If all headers have not been parsed, the actual count could decrease if \nMultipleHeader\n instances exist. If you need an exact count, iterate.\n\n\n\n\n\n\ntoString() : string\n\n\nRender all headers at once.  This method handles the normal iteration of headers; it is up to the concrete classes to prepend with the appropriate status/request line.\n\n\n\n\n\n\ntoArray() : array\n\n\nReturn all headers as an associative array.\n\n\n\n\n\n\nforceLoading() : bool\n\n\nBy calling this, it will force parsing and loading of all headers, ensuring \ncount()\n is accurate.\n\n\n\n\n\n\n\n\nHeaderInterface Methods\n\n\nThe following are methods available to all \nHeaderInterface\n implementations.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstatic fromString(string $headerLine) : HeaderInterface\n\n\nFactory to generate a header object from a string.\n\n\n\n\n\n\ngetFieldName() : string\n\n\nRetrieve header field name.\n\n\n\n\n\n\ngetFieldValue() : string\n\n\nRetrieve header field value.\n\n\n\n\n\n\ntoString() : string\n\n\nCast the header to a well-formed HTTP header line (\nName: Value\n).\n\n\n\n\n\n\n\n\nAbstractAccept Methods\n\n\nZend\\Http\\Header\\AbstractAccept\n defines the following methods in addition to\nthose it inherits from the \nHeaderInterface\n. The\n\nAccept\n, \nAcceptCharset\n, \nAcceptEncoding\n, and \nAcceptLanguage\n header types\ninherit from it.\n\n\nFor brevity, we map the following references to the following classes or\nnamespaces:\n\n\n\n\nAcceptFieldValuePart\n: \nZend\\Http\\Header\\Accept\\FieldValuePart\\AcceptFieldValuePart\n\n\nInvalidArgumentException\n: \nZend\\Http\\Header\\Exception\\InvalidArgumentException\n\n\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nparseHeaderLine(string $headerLine) : void\n\n\nParse the given header line and add the values discovered to the instance.\n\n\n\n\n\n\ngetFieldValuePartsFromHeaderLine(string $headerLine) : array\n\n\nParse the field value parts represented by an Accept* header line.  Throws \nInvalidArgumentException\n if the header is invalid.\n\n\n\n\n\n\ngetFieldValue(array|null $values = null) : string\n\n\nGet field value.\n\n\n\n\n\n\nmatch(array|string $matchAgainst) : bool|AcceptFieldValuePart\n\n\nMatch a media string against this header. Returns the matched value or false.\n\n\n\n\n\n\ngetPrioritized() : array\n\n\nReturns all the keys, values and parameters this header represents.\n\n\n\n\n\n\n\n\nAbstractDate Methods\n\n\nZend\\Http\\Header\\AbstractDate\n defines the following methods in addition to\nthose it inherits from the \nHeaderInterface\n. The\n\nDate\n, \nExpires\n, \nIfModifiedSince\n, \nIfUnmodifiedSince\n, \nLastModified\n, and\n\nRetryAfter\n header types inherit from it.\n\n\nFor brevity, we map the following references to the following classes or\nnamespaces:\n\n\n\n\nInvalidArgumentException\n: \nZend\\Http\\Header\\Exception\\InvalidArgumentException\n\n\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstatic fromTimestamp(int $time) : AbstractDate\n\n\nCreate date-based header from Unix timestamp.\n\n\n\n\n\n\nstatic fromTimeString(string $time) : AbstractDate\n\n\nCreate date-based header from \nstrtotime()\n-compatible string.\n\n\n\n\n\n\nstatic setDateFormat(int $format) : void\n\n\nSet date output format; should be an index from the implementation's \n$dateFormat\n static property.\n\n\n\n\n\n\nstatic getDateFormat() : string\n\n\nReturn current date output format.\n\n\n\n\n\n\nsetDate(string|DateTime $date) : self\n\n\nSet the date for this header; this can be a string or an instance of \nDateTime\n.  Throws \nInvalidArgumentException\n if the date is neither a valid string nor an instance of \nDateTime\n.\n\n\n\n\n\n\ngetDate() : string\n\n\nReturn string representation of the date for this header.\n\n\n\n\n\n\ncompareTo(string|DateTime $date) : int\n\n\nCompare provided date to date for this header. Returns \n< 0\n if date in header is less than \n$date\n; \n> 0\n if it's greater, and \n= 0\n if they are equal. See \nstrcmp\n.\n\n\n\n\n\n\ndate() | DateTime\n\n\nReturn date for this header as an instance of \nDateTime\n.\n\n\n\n\n\n\n\n\nAbstractLocation Methods\n\n\nZend\\Http\\Header\\AbstractLocation\n defines the following methods in addition to\nthose it inherits from the \nHeaderInterface\n. The\n\nContentLocation\n, \nLocation\n, and \nReferer\n header types inherit from it.\n\n\nFor brevity, we map the following references to the following classes or\nnamespaces:\n\n\n\n\nUri\n: \nZend\\Uri\\UriInterface\n\n\nInvalidArgumentException\n: \nZend\\Http\\Header\\Exception\\InvalidArgumentException\n\n\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsetUri(string|Uri $uri) : self\n\n\nSet the URI for this header; throws \nInvalidArgumentException\n for invalid \n$uri\n arguments.\n\n\n\n\n\n\ngetUri() : string\n\n\nReturn the URI for this header.\n\n\n\n\n\n\nuri() : Uri\n\n\nReturn the \nUri\n instance for this header.\n\n\n\n\n\n\n\n\nList of HTTP Header Types\n\n\nSome header classes expose methods for manipulating their value. The following\nlist contains all of the classes available in the \nZend\\Http\\Header\\*\n\nnamespace, as well as any specific methods they contain. Each class implements\n\nZend\\Http\\Header\\HeaderInterface\n.\n\n\nAccept\n\n\nExtends \nAbstractAccept\n.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\naddMediaType(string $type, int|float $priority = 1) : self\n\n\nAdd a media type, with the given priority.\n\n\n\n\n\n\nhasMediaType(string $type): bool\n\n\nDoes the header have the requested media type?\n\n\n\n\n\n\n\n\nAcceptCharset\n\n\nExtends \nAbstractAccept\n.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\naddCharset(string $type, int|float $priority = 1) : self\n\n\nAdd a charset, with the given priority.\n\n\n\n\n\n\nhasCharset(string $type) : bool\n\n\nDoes the header have the requested charset?\n\n\n\n\n\n\n\n\nAcceptEncoding\n\n\nExtends \nAbstractAccept\n.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\naddEncoding(string $type, int|float $priority = 1) : self\n\n\nAdd an encoding, with the given priority.\n\n\n\n\n\n\nhasEncoding(string $type) : bool\n\n\nDoes the header have the requested encoding?\n\n\n\n\n\n\n\n\nAcceptLanguage\n\n\nExtends \nAbstractAccept\n.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\naddLanguage(string $type, int|float $priority = 1): self\n\n\nAdd a language, with the given priority.\n\n\n\n\n\n\nhasLanguage(string $type) : bool\n\n\nDoes the header have the requested language?\n\n\n\n\n\n\n\n\nAcceptRanges\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetRangeUnit() : mixed\n\n\n(unknown)\n\n\n\n\n\n\nsetRangeUnit(mixed $rangeUnit) : self\n\n\n(unkown)\n\n\n\n\n\n\n\n\nAge\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetDeltaSeconds() : int\n\n\nGet number of seconds.\n\n\n\n\n\n\nsetDeltaSeconds(int $seconds) : self\n\n\nSet number of seconds\n\n\n\n\n\n\n\n\nAllow\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetAllMethods() : string[]\n\n\nGet list of all defined methods.\n\n\n\n\n\n\ngetAllowedMethods() : string[]\n\n\nGet list of allowed methods.\n\n\n\n\n\n\nallowMethods(array|string $allowedMethods) : self\n\n\nAllow methods or list of methods.\n\n\n\n\n\n\ndisallowMethods(array|string $allowedMethods) self\n\n\nDisallow methods or list of methods.\n\n\n\n\n\n\ndenyMethods(array|string $allowedMethods) : self\n\n\nConvenience alias for \ndisallowMethods()\n.\n\n\n\n\n\n\nisAllowedMethod(string $method) : bool\n\n\nCheck whether method is allowed.\n\n\n\n\n\n\n\n\nAuthenticationInfo\n\n\nNo additional methods.\n\n\nAuthorization\n\n\nNo additional methods.\n\n\nCacheControl\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nisEmpty(): bool\n\n\nChecks if the internal directives array is empty.\n\n\n\n\n\n\naddDirective(string $key, string|bool $value = true) : self\n\n\nAdd a directive. For directives like \nmax-age=60\n, call as \naddDirective('max-age', 60)\n. For directives like \nprivate\n, use the default \n$value\n (\ntrue\n).\n\n\n\n\n\n\nhasDirective(string $key) : bool\n\n\nCheck the internal directives array for a directive.\n\n\n\n\n\n\ngetDirective(string $key) : null|string\n\n\nFetch the value of a directive from the internal directive array.\n\n\n\n\n\n\nremoveDirective(string $key) : self\n\n\nRemove a directive.\n\n\n\n\n\n\n\n\nConnection\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsetValue($value) : self\n\n\nSet arbitrary header value.  RFC allows any token as value; 'close' and 'keep-alive' are commonly used.\n\n\n\n\n\n\nisPersistent() : bool\n\n\nWhether or not the connection is persistent.\n\n\n\n\n\n\nsetPersistent(bool $flag) : self\n\n\nSet Connection header to define persistent connection.\n\n\n\n\n\n\n\n\nContentDisposition\n\n\nNo additional methods.\n\n\nContentEncoding\n\n\nNo additional methods.\n\n\nContentLanguage\n\n\nNo additional methods.\n\n\nContentLength\n\n\nNo additional methods.\n\n\nContentLocation\n\n\nSee \nAbstractLocation\n.\n\n\nContentMD5\n\n\nNo additional methods.\n\n\nContentRange\n\n\nNo additional methods.\n\n\nContentSecurityPolicy\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetDirectives(): array\n\n\nRetrieve the defined directives for the policy.\n\n\n\n\n\n\nsetDirective(string $name, array $sources) : self\n\n\nSet the directive with the given name to include the sources. See below for an example.\n\n\n\n\n\n\n\n\nAs an example: an auction site wishes to load images from any URI, plugin\ncontent from a list of trusted media providers (including a content distribution\nnetwork), and scripts only from a server under its control hosting sanitized\nJavacript:\n\n\n// http://www.w3.org/TR/2012/CR-CSP-20121115/#sample-policy-definitions\n$csp = new ContentSecurityPolicy();\n$csp->setDirective('default-src', []); // No sources\n$csp->setDirective('img-src', ['*']);\n$csp->setDirective('object-src', ['media1.example.com', 'media2.example.com', '*.cdn.example.com']);\n$csp->setDirective('script-src', ['trustedscripts.example.com']);\n\n\n\nContentTransferEncoding\n\n\nNo additional methods.\n\n\nContentType\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmatch(array|string $matchAgainst) : bool|string\n\n\nDetermine if the mediatype value in this header matches the provided criteria.\n\n\n\n\n\n\ngetMediaType() : string\n\n\nGet the media type.\n\n\n\n\n\n\nsetMediaType(string $mediaType) : self\n\n\nSet the media type.\n\n\n\n\n\n\ngetParameters() : array\n\n\nGet any additional content-type parameters currently set.\n\n\n\n\n\n\nsetParameters(array $parameters) : self\n\n\nSet additional content-type parameters.\n\n\n\n\n\n\ngetCharset() : null|string\n\n\nGet the content-type character set encoding, if any.\n\n\n\n\n\n\nsetCharset(string $charset) : self\n\n\nSet the content-type character set encoding.\n\n\n\n\n\n\n\n\nCookie\n\n\nExtends \nArrayObject\n.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstatic fromSetCookieArray(array $setCookies) : Cookie\n\n\nCreate an instance from the \n$_COOKIE\n array, or one structured like it.\n\n\n\n\n\n\nsetEncodeValue(bool $encode) : self\n\n\nSet flag indicating whether or not to \nurlencode()\n the cookie values.\n\n\n\n\n\n\ngetEncodeValue() : bool\n\n\nGet flag indicating whether or not to \nurlencode()\n the cookie values.\n\n\n\n\n\n\n\n\nDate\n\n\nSee \nAbstractDate\n.\n\n\nEtag\n\n\nNo additional methods.\n\n\nExpect\n\n\nNo additional methods.\n\n\nExpires\n\n\nSee \nAbstractDate\n.\n\n\nFrom\n\n\nNo additional methods.\n\n\nHost\n\n\nNo additional methods.\n\n\nIfMatch\n\n\nNo additional methods.\n\n\nIfModifiedSince\n\n\nSee \nAbstractDate\n.\n\n\nIfNoneMatch\n\n\nNo additional methods.\n\n\nIfRange\n\n\nNo additional methods.\n\n\nIfUnmodifiedSince\n\n\nSee \nAbstractDate\n.\n\n\nKeepAlive\n\n\nNo additional methods.\n\n\nLastModified\n\n\nSee \nAbstractDate\n.\n\n\nLocation\n\n\nSee \nAbstractLocation\n.\n\n\nMaxForwards\n\n\nNo additional methods.\n\n\nOrigin\n\n\nNo additional methods.\n\n\nPragma\n\n\nNo additional methods.\n\n\nProxyAuthenticate\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntoStringMultipleHeaders(array $headers) : string\n\n\nCreates a string representation when multiple values are present.\n\n\n\n\n\n\n\n\nProxyAuthorization\n\n\nNo additional methods.\n\n\nRange\n\n\nNo additional methods.\n\n\nReferer\n\n\nSee \nAbstractLocation\n.\n\n\nRefresh\n\n\nNo additional methods.\n\n\nRetryAfter\n\n\nSee \nAbstractDate\n.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsetDeltaSeconds(int $delta) : self\n\n\nSet number of seconds.\n\n\n\n\n\n\ngetDeltaSeconds() : int\n\n\nGet number of seconds.\n\n\n\n\n\n\n\n\nServer\n\n\nNo additional methods.\n\n\nSetCookie\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstatic matchCookieDomain(string $cookieDomain, string $host) : bool\n\n\nCheck if a cookie's domain matches a host name.\n\n\n\n\n\n\nstatic matchCookiePath(string $cookiePath, string $path) : bool\n\n\nCheck if a cookie's path matches a URL path.\n\n\n\n\n\n\ngetName() : string\n\n\nRetrieve the cookie name.\n\n\n\n\n\n\nsetName(string $name) : self\n\n\nSet the cookie name.\n\n\n\n\n\n\ngetValue() : string\n\n\nRetrieve the cookie value.\n\n\n\n\n\n\nsetValue(string $value) : self\n\n\nSet the cookie value.\n\n\n\n\n\n\ngetExpires() : int\n\n\nRetrieve the expiration date for the cookie.\n\n\n\n\n\n\nsetExpires(int|string $expires) : self\n\n\nSet the cookie expiration timestamp; null indicates a session cookie.\n\n\n\n\n\n\ngetPath() : string\n\n\nRetrieve the URI path the cookie is bound to.\n\n\n\n\n\n\nsetPath(string $path) : self\n\n\nSet the URI path the cookie is bound to.\n\n\n\n\n\n\ngetDomain() : string\n\n\nRetrieve the domain the cookie is bound to.\n\n\n\n\n\n\nsetDomain(string $domain) : self\n\n\nSet the domain the cookie is bound to.\n\n\n\n\n\n\ngetMaxAge() : int\n\n\nRetrieve the maximum age for the cookie.\n\n\n\n\n\n\nsetMaxAge(int|string $maxAge) : self\n\n\nSet the maximum age for the cookie.\n\n\n\n\n\n\ngetVersion() : int\n\n\nRetrieve the cookie version.\n\n\n\n\n\n\nsetVersion(int|string $version) : self\n\n\nSet the cookie version.\n\n\n\n\n\n\nisSecure(): bool\n\n\nWhether the cookies contains the Secure flag.\n\n\n\n\n\n\nsetSecure(bool $secure) : self\n\n\nSet whether the cookies contain the Secure flag.\n\n\n\n\n\n\nisHttponly() : bool\n\n\nWhether the cookies can be accessed via the HTTP protocol only.\n\n\n\n\n\n\nsetHttponly(bool $httponly) : self\n\n\nSet whether the cookies can be accessed only via HTTP protocol.\n\n\n\n\n\n\nisExpired() : bool\n\n\nWhether the cookie is expired.\n\n\n\n\n\n\nisSessionCookie() : bool\n\n\nWhether the cookie is a session cookie.\n\n\n\n\n\n\nsetQuoteFieldValue(bool $quotedValue) : self\n\n\nSet whether the value for this cookie should be quoted.\n\n\n\n\n\n\nhasQuoteFieldValue() : bool\n\n\nCheck whether the value for this cookie should be quoted.\n\n\n\n\n\n\nisValidForRequest() : bool\n\n\nWhether the cookie is valid for a given request domain, path and isSecure.\n\n\n\n\n\n\nmatch(string $uri, bool $matchSessionCookies, int $now) : bool\n\n\nChecks whether the cookie should be sent or not in a specific scenario.\n\n\n\n\n\n\ntoStringMultipleHeaders(array $headers) : string\n\n\nReturns string representation when multiple values are present.\n\n\n\n\n\n\n\n\nTE\n\n\nNo additional methods.\n\n\nTrailer\n\n\nNo additional methods.\n\n\nTransferEncoding\n\n\nNo additional methods.\n\n\nUpgrade\n\n\nNo additional methods.\n\n\nUserAgent\n\n\nNo additional methods.\n\n\nVary\n\n\nNo additional methods.\n\n\nVia\n\n\nNo additional methods.\n\n\nWarning\n\n\nNo additional methods.\n\n\nWWWAuthenticate\n\n\nDefines a \ntoStringMultipleHeaders(array $headers)\n method for serializing to\nstring when multiple values are present.\n\n\nExamples\n\n\nRetrieving headers from a Headers object\n\n\n// $client is an instance of Zend\\Http\\Client\n$response = $client->send();\n$headers = $response->getHeaders();\n\n// We can check if the Request contains a specific header by\n// using the ``has`` method. Returns boolean ``TRUE`` if at least\n// one matching header found, and ``FALSE`` otherwise\n$headers->has('Content-Type');\n\n// We can retrieve all instances of a specific header by using\n// the ``get`` method:\n$contentTypeHeaders = $headers->get('Content-Type');\n\n\n\nThere are three possibilities for the return value of the above call to the \nget\n method:\n\n\n\n\nIf no \nContent-Type\n header was set in the \nRequest\n, \nget\n will return \nfalse\n.\n\n\nIf only one \nContent-Type\n header was set in the \nRequest\n, \nget\n will return\n  an instance of \nZend\\Http\\Header\\ContentType\n.\n\n\nIf more than one \nContent-Type\n header was set in the \nRequest\n, \nget\n will\n  return an \nArrayIterator\n containing one \nZend\\Http\\Header\\ContentType\n\n  instance per header.\n\n\n\n\nAdding headers to a Headers object\n\n\nuse Zend\\Http\\Header;\nuse Zend\\Http\\Headers;\n\n$headers = new Headers();\n\n// We can directly add any object that implements Zend\\Http\\Header\\HeaderInterface\n$typeHeader = Header\\ContentType::fromString('Content-Type: text/html');\n$headers->addHeader($typeHeader);\n\n// We can add headers using the raw string representation, either\n// passing the header name and value as separate arguments...\n$headers->addHeaderLine('Content-Type', 'text/html');\n\n// .. or we can pass the entire header as the only argument\n$headers->addHeaderLine('Content-Type: text/html');\n\n// We can also add headers in bulk using addHeaders, which accepts\n// an array of individual header definitions that can be in any of\n// the accepted formats outlined below:\n$headers->addHeaders([\n    // An object implementing Header\\HeaderInterface\n    Header\\ContentType::fromString('Content-Type: text/html'),\n\n    // A raw header string\n    'Content-Type: text/html',\n\n    // We can also pass the header name as the array key and the\n    // header content as that array key's value\n    'Content-Type' => 'text/html',\n]);\n\n\n\nRemoving headers from a Headers object\n\n\nWe can remove all headers of a specific type using the \nremoveHeader\n method,\nwhich accepts a single object implementing \nZend\\Http\\Header\\HeaderInterface\n\n\nuse ArrayIterator;\nuse Zend\\Http\\Header\\HeaderInterface;\n\n// $headers is a pre-configured instance of Zend\\Http\\Headers\n\n// We can also delete individual headers or groups of headers\n$matches = $headers->get('Content-Type');\n\nif ($matches instanceof ArrayIterator) {\n    // If more than one header was found, iterate over the collection\n    // and remove each one individually\n    foreach ($headers as $header) {\n        $headers->removeHeader($header);\n    }\n} elseif ($matches instanceof HeaderInterface) {\n    // If only a single header was found, remove it directly\n    $headers->removeHeader($header);\n}\n\n// In addition to this, we can clear all the headers currently stored in\n// the container by calling the clearHeaders() method\n$matches->clearHeaders();",
            "title": "Headers"
        },
        {
            "location": "/headers/#headers",
            "text": "Zend\\Http\\Headers  is a container for HTTP headers. It is typically accessed as\npart of a  Zend\\Http\\Request  or  Zend\\Http\\Response  instance, via a getHeaders()  call. The  Headers  container will lazily load actual Zend\\Http\\Header\\HeaderInterface  instances as to reduce the overhead of header\nspecific parsing.  The class under the  Zend\\Http\\Header  namespace are the domain specific\nimplementations for the various types of headers that one might encounter during\nthe typical HTTP request. If a header of unknown type is encountered, it will be\nimplemented as a  Zend\\Http\\Header\\GenericHeader  instance. See the below table\nfor a list of the various HTTP headers and the API that is specific to each\nheader type.",
            "title": "Headers"
        },
        {
            "location": "/headers/#quick-start",
            "text": "The quickest way to get started interacting with header objects is by retrieving\nan already populated  Headers  container from a request or response instance.  // $client is an instance of Zend\\Http\\Client\n\n// You can retrieve the request headers by first retrieving\n// the Request object and then calling getHeaders on it\n$requestHeaders  = $client->getRequest()->getHeaders();\n\n// The same method also works for retrieving Response headers\n$responseHeaders = $client->getResponse()->getHeaders();  Zend\\Http\\Headers  can also extract headers from a string:  use Zend\\Http\\Headers;\n\n$headerString = <<<EOB\nHost: www.example.com\nContent-Type: text/html\nContent-Length: 1337\nEOB;\n\n$headers = Headers::fromString($headerString);\n// $headers is now populated with three objects\n//   (1) Zend\\Http\\Header\\Host\n//   (2) Zend\\Http\\Header\\ContentType\n//   (3) Zend\\Http\\Header\\ContentLength  Now that you have an instance of  Zend\\Http\\Headers , you can manipulate the\nindividual headers it contains using the provided public API methods outlined in\nthe  Available Methods  section.",
            "title": "Quick Start"
        },
        {
            "location": "/headers/#configuration-options",
            "text": "No configuration options are available.",
            "title": "Configuration Options"
        },
        {
            "location": "/headers/#available-methods",
            "text": "The following is a list of methods available to  Zend\\Http\\Headers . For\nbrevity, we map the following references to the following classes or namespaces:   HeaderInterface :  Zend\\Http\\Header\\HeaderInterface  Headers :  Zend\\Http\\Headers  PluginClassLocator :  Zend\\Loader\\PluginClassLocator      Method signature  Description      static fromString(string $string) : Headers  Parses a string for headers, and aggregates them, in order, a new  Headers  instance, primarily as strings until they are needed (they will be lazy loaded).    setPluginClassLoader(PluginClassLocator $pluginClassLoader) : self  Set an alternate implementation for the plugin class loader.    getPluginClassLoader() : PluginClassLocator  Return an instance of a  PluginClassLocator ; lazy-load and inject map if necessary.    addHeaders(array|Traversable $headers) : self  Add many headers at once; expects an array (or  Traversable  object) of type/value pairs.    addHeaderLine(string $headerFieldNameOrLine, string $fieldValue) : self  Add a raw header line, either as separate name and value arguments, or as a single string in the form  name: value  This method allows for lazy-loading in that the parsing and instantiation of a  HeaderInterface  implementation will be delayed until they are retrieved by either  get()  or  current() .    addHeader(HeaderInterface $header) : self  Add a header instance to the container; for raw values see  addHeaderLine()  and  addHeaders() .    removeHeader(HeaderInterface $header) : bool  Remove a Header from the container.    clearHeaders() : self  Removes all headers from the container.    get(string $name) : false|HeaderInterface|ArrayIterator  Get all values for a given header. If none are found,  false  is returned. If the header is a single-value header, a  HeaderInterface  is returned. If the header is a multi-value header, an  ArrayIterator  containing all values is returned.    has(string $name) : bool  Test for existence of a header.    next() : void  Advance the pointer for this object as an iterator.    key() : mixed  Return the current key for this object as an iterator.    valid() : bool  Is this iterator still valid?    rewind() : void  Reset the internal pointer for this object as an iterator.    current() : HeaderInterface  Return the current value for this iterator, lazy loading it if need be.    count() : int  Return the number of headers in this container. If all headers have not been parsed, the actual count could decrease if  MultipleHeader  instances exist. If you need an exact count, iterate.    toString() : string  Render all headers at once.  This method handles the normal iteration of headers; it is up to the concrete classes to prepend with the appropriate status/request line.    toArray() : array  Return all headers as an associative array.    forceLoading() : bool  By calling this, it will force parsing and loading of all headers, ensuring  count()  is accurate.",
            "title": "Available Methods"
        },
        {
            "location": "/headers/#headerinterface-methods",
            "text": "The following are methods available to all  HeaderInterface  implementations.     Method signature  Description      static fromString(string $headerLine) : HeaderInterface  Factory to generate a header object from a string.    getFieldName() : string  Retrieve header field name.    getFieldValue() : string  Retrieve header field value.    toString() : string  Cast the header to a well-formed HTTP header line ( Name: Value ).",
            "title": "HeaderInterface Methods"
        },
        {
            "location": "/headers/#abstractaccept-methods",
            "text": "Zend\\Http\\Header\\AbstractAccept  defines the following methods in addition to\nthose it inherits from the  HeaderInterface . The Accept ,  AcceptCharset ,  AcceptEncoding , and  AcceptLanguage  header types\ninherit from it.  For brevity, we map the following references to the following classes or\nnamespaces:   AcceptFieldValuePart :  Zend\\Http\\Header\\Accept\\FieldValuePart\\AcceptFieldValuePart  InvalidArgumentException :  Zend\\Http\\Header\\Exception\\InvalidArgumentException      Method signature  Description      parseHeaderLine(string $headerLine) : void  Parse the given header line and add the values discovered to the instance.    getFieldValuePartsFromHeaderLine(string $headerLine) : array  Parse the field value parts represented by an Accept* header line.  Throws  InvalidArgumentException  if the header is invalid.    getFieldValue(array|null $values = null) : string  Get field value.    match(array|string $matchAgainst) : bool|AcceptFieldValuePart  Match a media string against this header. Returns the matched value or false.    getPrioritized() : array  Returns all the keys, values and parameters this header represents.",
            "title": "AbstractAccept Methods"
        },
        {
            "location": "/headers/#abstractdate-methods",
            "text": "Zend\\Http\\Header\\AbstractDate  defines the following methods in addition to\nthose it inherits from the  HeaderInterface . The Date ,  Expires ,  IfModifiedSince ,  IfUnmodifiedSince ,  LastModified , and RetryAfter  header types inherit from it.  For brevity, we map the following references to the following classes or\nnamespaces:   InvalidArgumentException :  Zend\\Http\\Header\\Exception\\InvalidArgumentException      Method signature  Description      static fromTimestamp(int $time) : AbstractDate  Create date-based header from Unix timestamp.    static fromTimeString(string $time) : AbstractDate  Create date-based header from  strtotime() -compatible string.    static setDateFormat(int $format) : void  Set date output format; should be an index from the implementation's  $dateFormat  static property.    static getDateFormat() : string  Return current date output format.    setDate(string|DateTime $date) : self  Set the date for this header; this can be a string or an instance of  DateTime .  Throws  InvalidArgumentException  if the date is neither a valid string nor an instance of  DateTime .    getDate() : string  Return string representation of the date for this header.    compareTo(string|DateTime $date) : int  Compare provided date to date for this header. Returns  < 0  if date in header is less than  $date ;  > 0  if it's greater, and  = 0  if they are equal. See  strcmp .    date() | DateTime  Return date for this header as an instance of  DateTime .",
            "title": "AbstractDate Methods"
        },
        {
            "location": "/headers/#abstractlocation-methods",
            "text": "Zend\\Http\\Header\\AbstractLocation  defines the following methods in addition to\nthose it inherits from the  HeaderInterface . The ContentLocation ,  Location , and  Referer  header types inherit from it.  For brevity, we map the following references to the following classes or\nnamespaces:   Uri :  Zend\\Uri\\UriInterface  InvalidArgumentException :  Zend\\Http\\Header\\Exception\\InvalidArgumentException      Method signature  Description      setUri(string|Uri $uri) : self  Set the URI for this header; throws  InvalidArgumentException  for invalid  $uri  arguments.    getUri() : string  Return the URI for this header.    uri() : Uri  Return the  Uri  instance for this header.",
            "title": "AbstractLocation Methods"
        },
        {
            "location": "/headers/#list-of-http-header-types",
            "text": "Some header classes expose methods for manipulating their value. The following\nlist contains all of the classes available in the  Zend\\Http\\Header\\* \nnamespace, as well as any specific methods they contain. Each class implements Zend\\Http\\Header\\HeaderInterface .",
            "title": "List of HTTP Header Types"
        },
        {
            "location": "/headers/#accept",
            "text": "Extends  AbstractAccept .     Method signature  Description      addMediaType(string $type, int|float $priority = 1) : self  Add a media type, with the given priority.    hasMediaType(string $type): bool  Does the header have the requested media type?",
            "title": "Accept"
        },
        {
            "location": "/headers/#acceptcharset",
            "text": "Extends  AbstractAccept .     Method signature  Description      addCharset(string $type, int|float $priority = 1) : self  Add a charset, with the given priority.    hasCharset(string $type) : bool  Does the header have the requested charset?",
            "title": "AcceptCharset"
        },
        {
            "location": "/headers/#acceptencoding",
            "text": "Extends  AbstractAccept .     Method signature  Description      addEncoding(string $type, int|float $priority = 1) : self  Add an encoding, with the given priority.    hasEncoding(string $type) : bool  Does the header have the requested encoding?",
            "title": "AcceptEncoding"
        },
        {
            "location": "/headers/#acceptlanguage",
            "text": "Extends  AbstractAccept .     Method signature  Description      addLanguage(string $type, int|float $priority = 1): self  Add a language, with the given priority.    hasLanguage(string $type) : bool  Does the header have the requested language?",
            "title": "AcceptLanguage"
        },
        {
            "location": "/headers/#acceptranges",
            "text": "Method signature  Description      getRangeUnit() : mixed  (unknown)    setRangeUnit(mixed $rangeUnit) : self  (unkown)",
            "title": "AcceptRanges"
        },
        {
            "location": "/headers/#age",
            "text": "Method signature  Description      getDeltaSeconds() : int  Get number of seconds.    setDeltaSeconds(int $seconds) : self  Set number of seconds",
            "title": "Age"
        },
        {
            "location": "/headers/#allow",
            "text": "Method signature  Description      getAllMethods() : string[]  Get list of all defined methods.    getAllowedMethods() : string[]  Get list of allowed methods.    allowMethods(array|string $allowedMethods) : self  Allow methods or list of methods.    disallowMethods(array|string $allowedMethods) self  Disallow methods or list of methods.    denyMethods(array|string $allowedMethods) : self  Convenience alias for  disallowMethods() .    isAllowedMethod(string $method) : bool  Check whether method is allowed.",
            "title": "Allow"
        },
        {
            "location": "/headers/#authenticationinfo",
            "text": "No additional methods.",
            "title": "AuthenticationInfo"
        },
        {
            "location": "/headers/#authorization",
            "text": "No additional methods.",
            "title": "Authorization"
        },
        {
            "location": "/headers/#cachecontrol",
            "text": "Method signature  Description      isEmpty(): bool  Checks if the internal directives array is empty.    addDirective(string $key, string|bool $value = true) : self  Add a directive. For directives like  max-age=60 , call as  addDirective('max-age', 60) . For directives like  private , use the default  $value  ( true ).    hasDirective(string $key) : bool  Check the internal directives array for a directive.    getDirective(string $key) : null|string  Fetch the value of a directive from the internal directive array.    removeDirective(string $key) : self  Remove a directive.",
            "title": "CacheControl"
        },
        {
            "location": "/headers/#connection",
            "text": "Method signature  Description      setValue($value) : self  Set arbitrary header value.  RFC allows any token as value; 'close' and 'keep-alive' are commonly used.    isPersistent() : bool  Whether or not the connection is persistent.    setPersistent(bool $flag) : self  Set Connection header to define persistent connection.",
            "title": "Connection"
        },
        {
            "location": "/headers/#contentdisposition",
            "text": "No additional methods.",
            "title": "ContentDisposition"
        },
        {
            "location": "/headers/#contentencoding",
            "text": "No additional methods.",
            "title": "ContentEncoding"
        },
        {
            "location": "/headers/#contentlanguage",
            "text": "No additional methods.",
            "title": "ContentLanguage"
        },
        {
            "location": "/headers/#contentlength",
            "text": "No additional methods.",
            "title": "ContentLength"
        },
        {
            "location": "/headers/#contentlocation",
            "text": "See  AbstractLocation .",
            "title": "ContentLocation"
        },
        {
            "location": "/headers/#contentmd5",
            "text": "No additional methods.",
            "title": "ContentMD5"
        },
        {
            "location": "/headers/#contentrange",
            "text": "No additional methods.",
            "title": "ContentRange"
        },
        {
            "location": "/headers/#contentsecuritypolicy",
            "text": "Method signature  Description      getDirectives(): array  Retrieve the defined directives for the policy.    setDirective(string $name, array $sources) : self  Set the directive with the given name to include the sources. See below for an example.     As an example: an auction site wishes to load images from any URI, plugin\ncontent from a list of trusted media providers (including a content distribution\nnetwork), and scripts only from a server under its control hosting sanitized\nJavacript:  // http://www.w3.org/TR/2012/CR-CSP-20121115/#sample-policy-definitions\n$csp = new ContentSecurityPolicy();\n$csp->setDirective('default-src', []); // No sources\n$csp->setDirective('img-src', ['*']);\n$csp->setDirective('object-src', ['media1.example.com', 'media2.example.com', '*.cdn.example.com']);\n$csp->setDirective('script-src', ['trustedscripts.example.com']);",
            "title": "ContentSecurityPolicy"
        },
        {
            "location": "/headers/#contenttransferencoding",
            "text": "No additional methods.",
            "title": "ContentTransferEncoding"
        },
        {
            "location": "/headers/#contenttype",
            "text": "Method signature  Description      match(array|string $matchAgainst) : bool|string  Determine if the mediatype value in this header matches the provided criteria.    getMediaType() : string  Get the media type.    setMediaType(string $mediaType) : self  Set the media type.    getParameters() : array  Get any additional content-type parameters currently set.    setParameters(array $parameters) : self  Set additional content-type parameters.    getCharset() : null|string  Get the content-type character set encoding, if any.    setCharset(string $charset) : self  Set the content-type character set encoding.",
            "title": "ContentType"
        },
        {
            "location": "/headers/#cookie",
            "text": "Extends  ArrayObject .     Method signature  Description      static fromSetCookieArray(array $setCookies) : Cookie  Create an instance from the  $_COOKIE  array, or one structured like it.    setEncodeValue(bool $encode) : self  Set flag indicating whether or not to  urlencode()  the cookie values.    getEncodeValue() : bool  Get flag indicating whether or not to  urlencode()  the cookie values.",
            "title": "Cookie"
        },
        {
            "location": "/headers/#date",
            "text": "See  AbstractDate .",
            "title": "Date"
        },
        {
            "location": "/headers/#etag",
            "text": "No additional methods.",
            "title": "Etag"
        },
        {
            "location": "/headers/#expect",
            "text": "No additional methods.",
            "title": "Expect"
        },
        {
            "location": "/headers/#expires",
            "text": "See  AbstractDate .",
            "title": "Expires"
        },
        {
            "location": "/headers/#from",
            "text": "No additional methods.",
            "title": "From"
        },
        {
            "location": "/headers/#host",
            "text": "No additional methods.",
            "title": "Host"
        },
        {
            "location": "/headers/#ifmatch",
            "text": "No additional methods.",
            "title": "IfMatch"
        },
        {
            "location": "/headers/#ifmodifiedsince",
            "text": "See  AbstractDate .",
            "title": "IfModifiedSince"
        },
        {
            "location": "/headers/#ifnonematch",
            "text": "No additional methods.",
            "title": "IfNoneMatch"
        },
        {
            "location": "/headers/#ifrange",
            "text": "No additional methods.",
            "title": "IfRange"
        },
        {
            "location": "/headers/#ifunmodifiedsince",
            "text": "See  AbstractDate .",
            "title": "IfUnmodifiedSince"
        },
        {
            "location": "/headers/#keepalive",
            "text": "No additional methods.",
            "title": "KeepAlive"
        },
        {
            "location": "/headers/#lastmodified",
            "text": "See  AbstractDate .",
            "title": "LastModified"
        },
        {
            "location": "/headers/#location",
            "text": "See  AbstractLocation .",
            "title": "Location"
        },
        {
            "location": "/headers/#maxforwards",
            "text": "No additional methods.",
            "title": "MaxForwards"
        },
        {
            "location": "/headers/#origin",
            "text": "No additional methods.",
            "title": "Origin"
        },
        {
            "location": "/headers/#pragma",
            "text": "No additional methods.",
            "title": "Pragma"
        },
        {
            "location": "/headers/#proxyauthenticate",
            "text": "Method signature  Description      toStringMultipleHeaders(array $headers) : string  Creates a string representation when multiple values are present.",
            "title": "ProxyAuthenticate"
        },
        {
            "location": "/headers/#proxyauthorization",
            "text": "No additional methods.",
            "title": "ProxyAuthorization"
        },
        {
            "location": "/headers/#range",
            "text": "No additional methods.",
            "title": "Range"
        },
        {
            "location": "/headers/#referer",
            "text": "See  AbstractLocation .",
            "title": "Referer"
        },
        {
            "location": "/headers/#refresh",
            "text": "No additional methods.",
            "title": "Refresh"
        },
        {
            "location": "/headers/#retryafter",
            "text": "See  AbstractDate .     Method signature  Description      setDeltaSeconds(int $delta) : self  Set number of seconds.    getDeltaSeconds() : int  Get number of seconds.",
            "title": "RetryAfter"
        },
        {
            "location": "/headers/#server",
            "text": "No additional methods.",
            "title": "Server"
        },
        {
            "location": "/headers/#setcookie",
            "text": "Method signature  Description      static matchCookieDomain(string $cookieDomain, string $host) : bool  Check if a cookie's domain matches a host name.    static matchCookiePath(string $cookiePath, string $path) : bool  Check if a cookie's path matches a URL path.    getName() : string  Retrieve the cookie name.    setName(string $name) : self  Set the cookie name.    getValue() : string  Retrieve the cookie value.    setValue(string $value) : self  Set the cookie value.    getExpires() : int  Retrieve the expiration date for the cookie.    setExpires(int|string $expires) : self  Set the cookie expiration timestamp; null indicates a session cookie.    getPath() : string  Retrieve the URI path the cookie is bound to.    setPath(string $path) : self  Set the URI path the cookie is bound to.    getDomain() : string  Retrieve the domain the cookie is bound to.    setDomain(string $domain) : self  Set the domain the cookie is bound to.    getMaxAge() : int  Retrieve the maximum age for the cookie.    setMaxAge(int|string $maxAge) : self  Set the maximum age for the cookie.    getVersion() : int  Retrieve the cookie version.    setVersion(int|string $version) : self  Set the cookie version.    isSecure(): bool  Whether the cookies contains the Secure flag.    setSecure(bool $secure) : self  Set whether the cookies contain the Secure flag.    isHttponly() : bool  Whether the cookies can be accessed via the HTTP protocol only.    setHttponly(bool $httponly) : self  Set whether the cookies can be accessed only via HTTP protocol.    isExpired() : bool  Whether the cookie is expired.    isSessionCookie() : bool  Whether the cookie is a session cookie.    setQuoteFieldValue(bool $quotedValue) : self  Set whether the value for this cookie should be quoted.    hasQuoteFieldValue() : bool  Check whether the value for this cookie should be quoted.    isValidForRequest() : bool  Whether the cookie is valid for a given request domain, path and isSecure.    match(string $uri, bool $matchSessionCookies, int $now) : bool  Checks whether the cookie should be sent or not in a specific scenario.    toStringMultipleHeaders(array $headers) : string  Returns string representation when multiple values are present.",
            "title": "SetCookie"
        },
        {
            "location": "/headers/#te",
            "text": "No additional methods.",
            "title": "TE"
        },
        {
            "location": "/headers/#trailer",
            "text": "No additional methods.",
            "title": "Trailer"
        },
        {
            "location": "/headers/#transferencoding",
            "text": "No additional methods.",
            "title": "TransferEncoding"
        },
        {
            "location": "/headers/#upgrade",
            "text": "No additional methods.",
            "title": "Upgrade"
        },
        {
            "location": "/headers/#useragent",
            "text": "No additional methods.",
            "title": "UserAgent"
        },
        {
            "location": "/headers/#vary",
            "text": "No additional methods.",
            "title": "Vary"
        },
        {
            "location": "/headers/#via",
            "text": "No additional methods.",
            "title": "Via"
        },
        {
            "location": "/headers/#warning",
            "text": "No additional methods.",
            "title": "Warning"
        },
        {
            "location": "/headers/#wwwauthenticate",
            "text": "Defines a  toStringMultipleHeaders(array $headers)  method for serializing to\nstring when multiple values are present.",
            "title": "WWWAuthenticate"
        },
        {
            "location": "/headers/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/headers/#retrieving-headers-from-a-headers-object",
            "text": "// $client is an instance of Zend\\Http\\Client\n$response = $client->send();\n$headers = $response->getHeaders();\n\n// We can check if the Request contains a specific header by\n// using the ``has`` method. Returns boolean ``TRUE`` if at least\n// one matching header found, and ``FALSE`` otherwise\n$headers->has('Content-Type');\n\n// We can retrieve all instances of a specific header by using\n// the ``get`` method:\n$contentTypeHeaders = $headers->get('Content-Type');  There are three possibilities for the return value of the above call to the  get  method:   If no  Content-Type  header was set in the  Request ,  get  will return  false .  If only one  Content-Type  header was set in the  Request ,  get  will return\n  an instance of  Zend\\Http\\Header\\ContentType .  If more than one  Content-Type  header was set in the  Request ,  get  will\n  return an  ArrayIterator  containing one  Zend\\Http\\Header\\ContentType \n  instance per header.",
            "title": "Retrieving headers from a Headers object"
        },
        {
            "location": "/headers/#adding-headers-to-a-headers-object",
            "text": "use Zend\\Http\\Header;\nuse Zend\\Http\\Headers;\n\n$headers = new Headers();\n\n// We can directly add any object that implements Zend\\Http\\Header\\HeaderInterface\n$typeHeader = Header\\ContentType::fromString('Content-Type: text/html');\n$headers->addHeader($typeHeader);\n\n// We can add headers using the raw string representation, either\n// passing the header name and value as separate arguments...\n$headers->addHeaderLine('Content-Type', 'text/html');\n\n// .. or we can pass the entire header as the only argument\n$headers->addHeaderLine('Content-Type: text/html');\n\n// We can also add headers in bulk using addHeaders, which accepts\n// an array of individual header definitions that can be in any of\n// the accepted formats outlined below:\n$headers->addHeaders([\n    // An object implementing Header\\HeaderInterface\n    Header\\ContentType::fromString('Content-Type: text/html'),\n\n    // A raw header string\n    'Content-Type: text/html',\n\n    // We can also pass the header name as the array key and the\n    // header content as that array key's value\n    'Content-Type' => 'text/html',\n]);",
            "title": "Adding headers to a Headers object"
        },
        {
            "location": "/headers/#removing-headers-from-a-headers-object",
            "text": "We can remove all headers of a specific type using the  removeHeader  method,\nwhich accepts a single object implementing  Zend\\Http\\Header\\HeaderInterface  use ArrayIterator;\nuse Zend\\Http\\Header\\HeaderInterface;\n\n// $headers is a pre-configured instance of Zend\\Http\\Headers\n\n// We can also delete individual headers or groups of headers\n$matches = $headers->get('Content-Type');\n\nif ($matches instanceof ArrayIterator) {\n    // If more than one header was found, iterate over the collection\n    // and remove each one individually\n    foreach ($headers as $header) {\n        $headers->removeHeader($header);\n    }\n} elseif ($matches instanceof HeaderInterface) {\n    // If only a single header was found, remove it directly\n    $headers->removeHeader($header);\n}\n\n// In addition to this, we can clear all the headers currently stored in\n// the container by calling the clearHeaders() method\n$matches->clearHeaders();",
            "title": "Removing headers from a Headers object"
        },
        {
            "location": "/client/intro/",
            "text": "HTTP Client\n\n\nZend\\Http\\Client\n provides an interface for performing Hyper-Text Transfer\nProtocol (HTTP) requests. \nZend\\Http\\Client\n supports all basic features\nexpected from an HTTP client, as well as some more complex features such as HTTP\nauthentication and file uploads. Successful requests (and most unsuccessful ones\ntoo) return a \nZend\\Http\\Response\n object, which provides access to the\nresponse's headers and body (see the chapter on \nResponses\n for\nmore details).\n\n\nQuick Start\n\n\nThe class constructor optionally accepts a URL as its first parameter (which can\nbe either a string or a \nZend\\Uri\\Http\n object), and an array or \nTraversable\n\nobject containing configuration options. The \nsend()\n method is used to submit\nthe request to the remote server, and a \nZend\\Http\\Response\n object is returned:\n\n\nuse Zend\\Http\\Client;\n\n$client = new Client(\n    'http://example.org',\n    [\n        'maxredirects' => 0,\n        'timeout'      => 30,\n    ]\n);\n$response = $client->send();\n\n\n\nBoth constructor parameters can be left out, and set later using the \nsetUri()\n\nand \nsetOptions()\n methods:\n\n\nuse Zend\\Http\\Client;\n\n$client = new Client();\n$client->setUri('http://example.org');\n$client->setOptions([\n    'maxredirects' => 0,\n    'timeout'      => 30,\n]);\n$response = $client->send();\n\n\n\nZend\\Http\\Client\n can also dispatch requests using a separately configured\n\nrequest\n object (see the \nRequest\n manual for full details of\nthe methods available):\n\n\nuse Zend\\Http\\Client;\nuse Zend\\Http\\Request;\n\n$request = new Request();\n$request->setUri('http://example.org');\n\n$client = new Client();\n\n$response = $client->send($request);\n\n\n\n\n\nURL validation\n\n\nZend\\Http\\Client\n uses \nZend\\Uri\\Http\n to validate URLs. See the\n\nzend-uri\n\ndocumentation for more information.\n\n\n\n\nConfiguration\n\n\nThe constructor and \nsetOptions()\n method accept an associative array or\n\nTraversable\n instance containing configuration parameters. Setting these\nparameters is optional, as they all have default values.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\nExpected Values\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nmaxredirects\n\n\nMaximum number of redirections to follow (0 = none)\n\n\ninteger\n\n\n5\n\n\n\n\n\n\nstrictredirects\n\n\nWhether to strictly follow the RFC when redirecting (see this section)\n\n\nboolean\n\n\nFALSE\n\n\n\n\n\n\nuseragent\n\n\nUser agent identifier string (sent in request headers)\n\n\nstring\n\n\nZend\\Http\\Client\n\n\n\n\n\n\ntimeout\n\n\nConnection timeout (seconds)\n\n\ninteger\n\n\n10\n\n\n\n\n\n\nhttpversion\n\n\nHTTP protocol version (usually '1.1' or '1.0')\n\n\nstring\n\n\n1.1\n\n\n\n\n\n\nadapter\n\n\nConnection adapter class to use (see this section)\n\n\nmixed\n\n\nZend\\Http\\Client\\Adapter\\Socket\n\n\n\n\n\n\nkeepalive\n\n\nWhether to enable keep-alive connections with the server. Useful and might improve performance if several consecutive requests to the same server are performed.\n\n\nboolean\n\n\nFALSE\n\n\n\n\n\n\nstoreresponse\n\n\nWhether to store last response for later retrieval with getLastResponse(). If set to FALSE, getLastResponse() will return NULL.\n\n\nboolean\n\n\nTRUE\n\n\n\n\n\n\nencodecookies\n\n\nWhether to pass the cookie value through urlencode/urldecode. Enabling this breaks support with some web servers. Disabling this limits the range of values the cookies can contain.\n\n\nboolean\n\n\nTRUE\n\n\n\n\n\n\noutputstream\n\n\nDestination for streaming of received data (options: string (filename), true for temp file, false/null to disable streaming)\n\n\nboolean\n\n\nFALSE\n\n\n\n\n\n\nrfc3986strict\n\n\nWhether to strictly adhere to RFC 3986 (in practice, this means replacing '+' with '%20')\n\n\nboolean\n\n\nFALSE\n\n\n\n\n\n\nsslcapath\n\n\nPath to SSL certificate directory\n\n\nstring\n\n\nNULL\n\n\n\n\n\n\nsslcafile\n\n\nPath to Certificate Authority (CA) bundle\n\n\nstring\n\n\nNULL\n\n\n\n\n\n\n\n\nThe options are also passed to the adapter class upon instantiation, so the same\nconfiguration can be used for adapter configuration. See the\n\nadapters\n section for more information on the adapter-specific\noptions available.\n\n\nExamples\n\n\nPerforming a GET request\n\n\nGET is the default method used, and requires no special configuration.\n\n\nuse Zend\\Http\\Client;\n\n$client = new Client('http://example.org');\n$response = $client->send();\n\n\n\nUsing request methods other than GET\n\n\nThe request method can be set using \nsetMethod()\n. If no method is specified,\nthe method set by the last \nsetMethod()\n call is used. If \nsetMethod()\n was\nnever called, the default request method is \nGET\n.\n\n\nuse Zend\\Http\\Client;\n\n$client = new Client('http://example.org');\n\n// Performing a POST request\n$client->setMethod('POST');\n$response = $client->send();\n\n\n\nFor convenience, \nZend\\Http\\Request\n defines all request methods as class\nconstants: \nZend\\Http\\Request::METHOD_GET\n, \nZend\\Http\\Request::METHOD_POST\n and\nso on.\n\n\nuse Zend\\Http\\Client;\nuse Zend\\Http\\Request;\n\n$client = new Client('http://example.org');\n\n// Performing a POST request\n$client->setMethod(Request::METHOD_POST);\n$response = $client->send();\n\n\n\nSetting query parameters\n\n\nAdding query parameters to an HTTP request can be done either by specifying them\nas part of the URL, or by using the \nsetParameterGet()\n method. This method\ntakes the query parameters as an associative array of name/value pairs.\n\n\nuse Zend\\Http\\Client;\n$client = new Client();\n\n// This is equivalent to setting a URL in the Client's constructor:\n$client->setUri('http://example.com/index.php?knight=lancelot');\n\n// Adding several parameters with one call\n$client->setParameterGet([\n    'first_name'  => 'Bender',\n    'middle_name' => 'Bending',\n    'last_name'   => 'Rodr\u00edguez',\n    'made_in'     => 'Mexico',\n]);\n\n\n\nSetting form-encoded body parameters\n\n\nWhile query parameters can be sent with every request method, other methods can\naccept parameters via the request body. In many cases, these are\n\napplication/x-www-form-urlencoded\n parameters; zend-http allows you to specify\nsuch parameters usingthe \nsetParameterPost()\n method, which is identical to the\n\nsetParameterGet()\n method in structure.\n\n\nuse Zend\\Http\\Client;\n\n$client = new Client();\n\n// Setting several POST parameters, one of them with several values\n$client->setParameterPost([\n    'language'  => 'es',\n    'country'   => 'ar',\n    'selection' => [45, 32, 80],\n]);\n\n\n\nNote that when sending \nPOST\n requests (or an request allowing a request body),\nyou can set both query and \nPOST\n parameters. On the other hand, setting POST\nparameters on a \nGET\n request will not trigger an error, rendering it useless.\n\n\nConnecting to SSL URLs\n\n\nIf you are trying to connect to an SSL or TLS (https) URL and are using the\ndefault (\nZend\\Http\\Client\\Adapter\\Socket\n) adapter, you may need to set the\n\nsslcapath\n configuration option in order to allow PHP to validate the SSL\ncertificate:\n\n\nuse Zend\\Http\\Client;\n\n$client = new Client(\n    'https://example.org',\n    [\n        'sslcapath' => '/etc/ssl/certs',\n    ]\n);\n$response = $client->send();\n\n\n\nThe exact path to use will vary depending on your operating system. Without this\nyou'll get the exception \"Unable to enable crypto on TCP connection\" when trying\nto connect.\n\n\nAlternatively, you could switch to the curl adapter, which negotiates SSL\nconnections more transparently:\n\n\nuse Zend\\Http\\Client;\n\n$client = new Client(\n    'https://example.org',\n    [\n        'adapter' => 'Zend\\Http\\Client\\Adapter\\Curl',\n    ]\n);\n$response = $client->send();\n\n\n\nComplete Example\n\n\nuse Zend\\Http\\Client;\n\n$client = new Client();\n$client->setUri('http://www.example.com');\n$client->setMethod('POST');\n$client->setParameterPost([\n    'foo' => 'bar',\n]);\n\n$response = $client->send();\n\nif ($response->isSuccess()) {\n    // the POST was successful\n}\n\n\n\nor the same thing, using a request object:\n\n\nuse Zend\\Http\\Client;\nuse Zend\\Http\\Request;\n\n$request = new Request();\n$request->setUri('http://www.example.com');\n$request->setMethod('POST');\n$request->getPost()->set('foo', 'bar');\n\n$client = new Client();\n$response = $client->send($request);\n\nif ($response->isSuccess()) {\n    // the POST was successful\n}",
            "title": "Intro"
        },
        {
            "location": "/client/intro/#http-client",
            "text": "Zend\\Http\\Client  provides an interface for performing Hyper-Text Transfer\nProtocol (HTTP) requests.  Zend\\Http\\Client  supports all basic features\nexpected from an HTTP client, as well as some more complex features such as HTTP\nauthentication and file uploads. Successful requests (and most unsuccessful ones\ntoo) return a  Zend\\Http\\Response  object, which provides access to the\nresponse's headers and body (see the chapter on  Responses  for\nmore details).",
            "title": "HTTP Client"
        },
        {
            "location": "/client/intro/#quick-start",
            "text": "The class constructor optionally accepts a URL as its first parameter (which can\nbe either a string or a  Zend\\Uri\\Http  object), and an array or  Traversable \nobject containing configuration options. The  send()  method is used to submit\nthe request to the remote server, and a  Zend\\Http\\Response  object is returned:  use Zend\\Http\\Client;\n\n$client = new Client(\n    'http://example.org',\n    [\n        'maxredirects' => 0,\n        'timeout'      => 30,\n    ]\n);\n$response = $client->send();  Both constructor parameters can be left out, and set later using the  setUri() \nand  setOptions()  methods:  use Zend\\Http\\Client;\n\n$client = new Client();\n$client->setUri('http://example.org');\n$client->setOptions([\n    'maxredirects' => 0,\n    'timeout'      => 30,\n]);\n$response = $client->send();  Zend\\Http\\Client  can also dispatch requests using a separately configured request  object (see the  Request  manual for full details of\nthe methods available):  use Zend\\Http\\Client;\nuse Zend\\Http\\Request;\n\n$request = new Request();\n$request->setUri('http://example.org');\n\n$client = new Client();\n\n$response = $client->send($request);",
            "title": "Quick Start"
        },
        {
            "location": "/client/intro/#url-validation",
            "text": "Zend\\Http\\Client  uses  Zend\\Uri\\Http  to validate URLs. See the zend-uri \ndocumentation for more information.",
            "title": "URL validation"
        },
        {
            "location": "/client/intro/#configuration",
            "text": "The constructor and  setOptions()  method accept an associative array or Traversable  instance containing configuration parameters. Setting these\nparameters is optional, as they all have default values.     Parameter  Description  Expected Values  Default Value      maxredirects  Maximum number of redirections to follow (0 = none)  integer  5    strictredirects  Whether to strictly follow the RFC when redirecting (see this section)  boolean  FALSE    useragent  User agent identifier string (sent in request headers)  string  Zend\\Http\\Client    timeout  Connection timeout (seconds)  integer  10    httpversion  HTTP protocol version (usually '1.1' or '1.0')  string  1.1    adapter  Connection adapter class to use (see this section)  mixed  Zend\\Http\\Client\\Adapter\\Socket    keepalive  Whether to enable keep-alive connections with the server. Useful and might improve performance if several consecutive requests to the same server are performed.  boolean  FALSE    storeresponse  Whether to store last response for later retrieval with getLastResponse(). If set to FALSE, getLastResponse() will return NULL.  boolean  TRUE    encodecookies  Whether to pass the cookie value through urlencode/urldecode. Enabling this breaks support with some web servers. Disabling this limits the range of values the cookies can contain.  boolean  TRUE    outputstream  Destination for streaming of received data (options: string (filename), true for temp file, false/null to disable streaming)  boolean  FALSE    rfc3986strict  Whether to strictly adhere to RFC 3986 (in practice, this means replacing '+' with '%20')  boolean  FALSE    sslcapath  Path to SSL certificate directory  string  NULL    sslcafile  Path to Certificate Authority (CA) bundle  string  NULL     The options are also passed to the adapter class upon instantiation, so the same\nconfiguration can be used for adapter configuration. See the adapters  section for more information on the adapter-specific\noptions available.",
            "title": "Configuration"
        },
        {
            "location": "/client/intro/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/client/intro/#performing-a-get-request",
            "text": "GET is the default method used, and requires no special configuration.  use Zend\\Http\\Client;\n\n$client = new Client('http://example.org');\n$response = $client->send();",
            "title": "Performing a GET request"
        },
        {
            "location": "/client/intro/#using-request-methods-other-than-get",
            "text": "The request method can be set using  setMethod() . If no method is specified,\nthe method set by the last  setMethod()  call is used. If  setMethod()  was\nnever called, the default request method is  GET .  use Zend\\Http\\Client;\n\n$client = new Client('http://example.org');\n\n// Performing a POST request\n$client->setMethod('POST');\n$response = $client->send();  For convenience,  Zend\\Http\\Request  defines all request methods as class\nconstants:  Zend\\Http\\Request::METHOD_GET ,  Zend\\Http\\Request::METHOD_POST  and\nso on.  use Zend\\Http\\Client;\nuse Zend\\Http\\Request;\n\n$client = new Client('http://example.org');\n\n// Performing a POST request\n$client->setMethod(Request::METHOD_POST);\n$response = $client->send();",
            "title": "Using request methods other than GET"
        },
        {
            "location": "/client/intro/#setting-query-parameters",
            "text": "Adding query parameters to an HTTP request can be done either by specifying them\nas part of the URL, or by using the  setParameterGet()  method. This method\ntakes the query parameters as an associative array of name/value pairs.  use Zend\\Http\\Client;\n$client = new Client();\n\n// This is equivalent to setting a URL in the Client's constructor:\n$client->setUri('http://example.com/index.php?knight=lancelot');\n\n// Adding several parameters with one call\n$client->setParameterGet([\n    'first_name'  => 'Bender',\n    'middle_name' => 'Bending',\n    'last_name'   => 'Rodr\u00edguez',\n    'made_in'     => 'Mexico',\n]);",
            "title": "Setting query parameters"
        },
        {
            "location": "/client/intro/#setting-form-encoded-body-parameters",
            "text": "While query parameters can be sent with every request method, other methods can\naccept parameters via the request body. In many cases, these are application/x-www-form-urlencoded  parameters; zend-http allows you to specify\nsuch parameters usingthe  setParameterPost()  method, which is identical to the setParameterGet()  method in structure.  use Zend\\Http\\Client;\n\n$client = new Client();\n\n// Setting several POST parameters, one of them with several values\n$client->setParameterPost([\n    'language'  => 'es',\n    'country'   => 'ar',\n    'selection' => [45, 32, 80],\n]);  Note that when sending  POST  requests (or an request allowing a request body),\nyou can set both query and  POST  parameters. On the other hand, setting POST\nparameters on a  GET  request will not trigger an error, rendering it useless.",
            "title": "Setting form-encoded body parameters"
        },
        {
            "location": "/client/intro/#connecting-to-ssl-urls",
            "text": "If you are trying to connect to an SSL or TLS (https) URL and are using the\ndefault ( Zend\\Http\\Client\\Adapter\\Socket ) adapter, you may need to set the sslcapath  configuration option in order to allow PHP to validate the SSL\ncertificate:  use Zend\\Http\\Client;\n\n$client = new Client(\n    'https://example.org',\n    [\n        'sslcapath' => '/etc/ssl/certs',\n    ]\n);\n$response = $client->send();  The exact path to use will vary depending on your operating system. Without this\nyou'll get the exception \"Unable to enable crypto on TCP connection\" when trying\nto connect.  Alternatively, you could switch to the curl adapter, which negotiates SSL\nconnections more transparently:  use Zend\\Http\\Client;\n\n$client = new Client(\n    'https://example.org',\n    [\n        'adapter' => 'Zend\\Http\\Client\\Adapter\\Curl',\n    ]\n);\n$response = $client->send();",
            "title": "Connecting to SSL URLs"
        },
        {
            "location": "/client/intro/#complete-example",
            "text": "use Zend\\Http\\Client;\n\n$client = new Client();\n$client->setUri('http://www.example.com');\n$client->setMethod('POST');\n$client->setParameterPost([\n    'foo' => 'bar',\n]);\n\n$response = $client->send();\n\nif ($response->isSuccess()) {\n    // the POST was successful\n}  or the same thing, using a request object:  use Zend\\Http\\Client;\nuse Zend\\Http\\Request;\n\n$request = new Request();\n$request->setUri('http://www.example.com');\n$request->setMethod('POST');\n$request->getPost()->set('foo', 'bar');\n\n$client = new Client();\n$response = $client->send($request);\n\nif ($response->isSuccess()) {\n    // the POST was successful\n}",
            "title": "Complete Example"
        },
        {
            "location": "/client/adapters/",
            "text": "HTTP Client Connection Adapters\n\n\nZend\\Http\\Client\n is based on a connection adapter design. The connection adapter is the object in\ncharge of performing the actual connection to the server, as well as writing requests and reading\nresponses. This connection adapter can be replaced, and you can create and extend the default\nconnection adapters to suit your special needs, without the need to extend or replace the entire\nHTTP client class.\n\n\nCurrently, zend-http provides four built-in client connection adapters:\n\n\n\n\nZend\\Http\\Client\\Adapter\\Socket\n (default)\n\n\nZend\\Http\\Client\\Adapter\\Proxy\n\n\nZend\\Http\\Client\\Adapter\\Curl\n\n\nZend\\Http\\Client\\Adapter\\Test\n\n\n\n\nThe client can accept an adapter via either its \nsetAdapter()\n method, or during\ninstantiation via its \nadapter\n configuration option. When using configuration,\nthe value of the \nadapter\n option may be one of:\n\n\n\n\nan adapter instance\n\n\nthe fully qualified class name of an adapter\n\n\n\n\nThe Socket adapter\n\n\nThe default connection adapter used when none is specified is the\n\nZend\\Http\\Client\\Adapter\\Socket\n adapter.  The \nSocket\n adapter is based on\nPHP's built-in \nfsockopen()\n function, and does not require any special\nextensions or compilation flags.\n\n\nThe \nSocket\n adapter allows several extra configuration options that can be set\nvia either the client's constructor or \nsetOptions()\n method:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\nExpected Type\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\npersistent\n\n\nWhether to use persistent TCP connections\n\n\nboolean\n\n\nFALSE\n\n\n\n\n\n\nssltransport\n\n\nSSL transport layer (eg. \nsslv2\n, \ntls\n)\n\n\nstring\n\n\nssl\n\n\n\n\n\n\nsslcert\n\n\nPath to a PEM encoded SSL certificate\n\n\nstring\n\n\nNULL\n\n\n\n\n\n\nsslpassphrase\n\n\nPassphrase for the SSL certificate file\n\n\nstring\n\n\nNULL\n\n\n\n\n\n\nsslverifypeer\n\n\nWhether to verify the SSL peer\n\n\nstring\n\n\nTRUE\n\n\n\n\n\n\nsslcapath\n\n\nPath to SSL certificate directory\n\n\nstring\n\n\nNULL\n\n\n\n\n\n\nsslallowselfsigned\n\n\nWhether to allow self-signed certificates\n\n\nstring\n\n\nFALSE\n\n\n\n\n\n\nsslusecontext\n\n\nEnables proxied connections to use SSL even if the proxy connection itself does not.\n\n\nboolean\n\n\nFALSE\n\n\n\n\n\n\n\n\n\n\nPersistent TCP connections\n\n\nUsing persistent TCP connections can potentially speed up HTTP requests, but\nin most use cases, will have little positive effect and might overload the\nHTTP server you are connecting to. It is recommended to use persistent TCP\nconnections only if you connect to the same server very frequently, and are\nsure that the server is capable of handling a large number of concurrent\nconnections. In any case you are encouraged to benchmark the effect of\npersistent connections on both the client speed and server load before using\nthis option.\n\n\nAdditionally, when using persistent connections, we recommend enabling\nKeep-Alive HTTP requests as described in \nthe client configuration section\n;\notherwise persistent connections might have little or no effect.\n\n\nHTTPS SSL stream parameters\n\n\nssltransport\n, \nsslcert\n and \nsslpassphrase\n are only relevant when\nconnecting using HTTPS.  While the default SSL/TLS settings should work for\nmost applications, you might need to change them if the server you are\nconnecting to requires special client setup. If so, please read the\n\nPHP manual chapter on SSL and TLS transport options\n.\n\n\n\n\nChanging the HTTPS transport layer\n\n\nuse Zend\\Http\\Client;\n\n// Set the configuration parameters\n$config = [\n    'adapter'      => Client\\Adapter\\Socket::class,\n    'ssltransport' => 'tls',\n];\n\n// Instantiate a client object\n$client = new Client('https://www.example.com', $config);\n\n// The following request will be sent over a TLS secure connection.\n$response = $client->send();\n\n\n\nThe result of the example above will be similar to opening a TCP connection\nusing the following PHP command:\n\n\nfsockopen('tls://www.example.com', 443);\n\n\n\nCustomizing and accessing the Socket adapter stream context\n\n\nZend\\Http\\Client\\Adapter\\Socket\n provides direct access to the underlying\n\nstream context\n used to connect to the remote\nserver. This allows the user to pass specific options and parameters to the TCP\nstream, and to the SSL wrapper in case of HTTPS connections.\n\n\nYou can access the stream context using the following methods of\n\nZend\\Http\\Client\\Adapter\\Socket\n:\n\n\n\n\nsetStreamContext($context)\n: Sets the stream context to be used by the\n  adapter. Can accept either a stream context resource created using the\n  \nstream_context_create()\n PHP function,\n  or an array of stream context options, in the same format provided to this\n  function.  Providing an array will create a new stream context using these\n  options, and set it.\n\n\ngetStreamContext()\n: Get the current stream context of the adapter. If no\n  stream context was set, this method will create a default stream context and\n  return it. You can then set or get the value of different context options\n  using regular PHP stream context functions.\n\n\n\n\nSetting stream context options for the Socket adapter\n\n\nuse Zend\\Http\\Client;\n\n// Array of options\n$options = [\n    'socket' => [\n        // Bind local socket side to a specific interface\n        'bindto' => '10.1.2.3:50505',\n    ],\n    'ssl'    => [\n        // Verify server side certificate,\n        // do not accept invalid or self-signed SSL certificates\n        'verify_peer'       => true,\n        'allow_self_signed' => false,\n\n        // Capture the peer's certificate\n        'capture_peer_cert' => true,\n    ],\n];\n\n// Create an adapter object and attach it to the HTTP client:\n$adapter = new Client\\Adapter\\Socket();\n$client  = new Client();\n$client->setAdapter($adapter);\n\n// Method 1: pass the options array to setStreamContext():\n$adapter->setStreamContext($options);\n\n// Method 2: create a stream context and pass it to setStreamContext():\n$context = stream_context_create($options);\n$adapter->setStreamContext($context);\n\n// Method 3: get the default stream context and set the options on it:\n$context = $adapter->getStreamContext();\nstream_context_set_option($context, $options);\n\n// Now, perform the request:\n$response = $client->send();\n\n// If everything went well, you can now access the context again:\n$opts = stream_context_get_options($adapter->getStreamContext());\necho $opts['ssl']['peer_certificate'];\n\n\n\n\n\nSet stream context options prior to requests\n\n\nNote that you must set any stream context options before using the adapter to\nperform actual requests. If no context is set before performing HTTP requests\nwith the \nSocket\n adapter, a default stream context will be created. This\ncontext resource could be accessed after performing any requests using the\n\ngetStreamContext()\n method.\n\n\n\n\nThe Proxy adapter\n\n\nZend\\Http\\Client\\Adapter\\Proxy\n is similar to the default \nSocket\n adapter; the\nprimary difference is that the connection is made through an HTTP proxy server\ninstead of a direct connection to the target server. This allows usage of\n\nZend\\Http\\Client\n behind proxy servers, which is sometimes required for\nsecurity or performance reasons.\n\n\nUsing the \nProxy\n adapter requires several additional client configuration\nparameters to be set, in addition to the default \nadapter\n option:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\nExpected Type\n\n\nExample Value\n\n\n\n\n\n\n\n\n\n\nproxy_host\n\n\nProxy server address\n\n\nstring\n\n\n'proxy.myhost.com'\u2019 or '10.1.2.3'\n\n\n\n\n\n\nproxy_port\n\n\nProxy server TCP port\n\n\ninteger\n\n\n8080 (default) or 81\n\n\n\n\n\n\nproxy_user\n\n\nProxy user name, if required\n\n\nstring\n\n\n'shahar' or '' for none (default)\n\n\n\n\n\n\nproxy_pass\n\n\nProxy password, if required\n\n\nstring\n\n\n'secret' or '' for none (default)\n\n\n\n\n\n\nproxy_auth\n\n\nProxy HTTP authentication type\n\n\nstring\n\n\nZend\\Http\\Client::AUTH_BASIC\n (default)\n\n\n\n\n\n\n\n\nproxy_host\n should always be set; if it is not set, the client will fall back\nto a direct connection using \nZend\\Http\\Client\\Adapter\\Socket\n. \nproxy_port\n\ndefaults to '8080'; if your proxy listens on a different port, you must set this\none as well.\n\n\nproxy_user\n and \nproxy_pass\n are only required if your proxy server requires\nyou to authenticate.  Providing these will add a 'Proxy-Authentication' header\nto the request. If your proxy does not require authentication, you can leave\nthese two options out.\n\n\nproxy_auth\n sets the proxy authentication type, if your proxy server requires\nauthentication.  Possible values are similar to the ones accepted by the\n\nZend\\Http\\Client::setAuth()\n method. Currently, only basic authentication\n(\nZend\\Http\\Client::AUTH_BASIC\n) is supported.\n\n\nUsing Zend\\Http\\Client behind a proxy server\n\n\nuse Zend\\Http\\Client;\n\n// Set the configuration parameters\n$config = [\n    'adapter'    => Client\\Adapter\\Proxy::class,\n    'proxy_host' => 'proxy.int.zend.com',\n    'proxy_port' => 8000,\n    'proxy_user' => 'shahar.e',\n    'proxy_pass' => 'bananashaped',\n];\n\n// Instantiate a client object\n$client = new Client('http://www.example.com', $config);\n\n// Continue working...\n\n\n\nAs mentioned, if \nproxy_host\n is not set or is set to a blank string, the\nconnection will fall back to a regular direct connection. This allows you to\nwrite your application in a way that allows a proxy to be used optionally,\naccording to a configuration parameter.\n\n\n\n\nAccess to stream context\n\n\nSince the proxy adapter inherits from \nZend\\Http\\Client\\Adapter\\Socket\n, you\ncan use the stream context access method (see\n\nabove\n) to set stream\ncontext options on \nProxy\n connections.\n\n\n\n\nThe cURL Adapter\n\n\ncURL is a standard HTTP client library that is distributed with many operating\nsystems and can be used in PHP via the cURL extension. It offers functionality\nfor many special cases which can occur for a HTTP client and make it a perfect\nchoice for a HTTP adapter. It supports secure connections, proxies, and multiple\nauthentication mechanisms. In particular, it is very performant with regards to\ntransfering large files.\n\n\nSetting cURL options\n\n\nuse Zend\\Http\\Client;\n\n$config = [\n    'adapter'     => Client\\Adapter\\Curl::class,\n    'curloptions' => [CURLOPT_FOLLOWLOCATION => true],\n];\n$client = new Client($uri, $config);\n\n\n\nBy default, the cURL adapter is configured to behave exactly like the \nSocket\n\nadapter, and it also accepts the same configuration parameters as the \nSocket\n\nand \nProxy\n adapters. You can also change the cURL options by either specifying\nthe 'curloptions' key in the constructor of the adapter, or by calling\n\nsetCurlOption($name, $value)\n; option names correspond to the \nCURL_*\n\nconstants of the cURL extension. You can get access to the underling cURL handle\nby calling \n$adapter->getHandle();\n\n\nThe cURL configuration options that can be set via \nsetCurlOption($name, $value)\n\nmethod are:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\nExpected Type\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nproxyuser\n\n\nWhether to use persistent TCP connections\n\n\nboolean\n\n\nFALSE\n\n\n\n\n\n\nproxypass\n\n\nSSL transport layer (eg. \nsslv2\n, \ntls\n)\n\n\nstring\n\n\nssl\n\n\n\n\n\n\nproxyhost\n\n\nPath to a PEM encoded SSL certificate\n\n\nstring\n\n\nNULL\n\n\n\n\n\n\nproxyport\n\n\nPassphrase for the SSL certificate file\n\n\nstring\n\n\nNULL\n\n\n\n\n\n\nsslverifypeer\n\n\nWhether to verify the SSL peer\n\n\nstring\n\n\nTRUE\n\n\n\n\n\n\n\n\nTransfering files by handle\n\n\nYou can use cURL to transfer very large files over HTTP by filehandle.\n\n\nuse Zend\\Http\\Client;\n\n$putFileSize   = filesize('filepath');\n$putFileHandle = fopen('filepath', 'r');\n\n$adapter = new Client\\Adapter\\Curl();\n$client = new Client();\n$client->setAdapter($adapter);\n$client->setMethod('PUT');\n$adapter->setOptions([\n    'curloptions' => [\n        CURLOPT_INFILE     => $putFileHandle,\n        CURLOPT_INFILESIZE => $putFileSize,\n    ],\n]);\n$client->send();\n\n\n\nThe Test adapter\n\n\nTesting code that relies on HTTP connections poses difficulties.  For example,\ntesting an application that pulls an RSS feed from a remote server will require\na network connection, which is not always available.\n\n\nZend\\Http\\Client\\Adapter\\Test\n provides a solution for these situations and\nacts as a mock object for unit tests. You can write your application to use\n\nZend\\Http\\Client\n, and, when testing (either in your unit test suite, or in\nnon-production environments), replace the default adapter with the test adapter,\nallowing you to run tests without actually performing server connections.\n\n\nZend\\Http\\Client\\Adapter\\Test\n provides two additional methods, \nsetResponse()\n\nand \naddResponse()\n.  Each takes one parameter, which represents an HTTP\nresponse as either text or a \nZend\\Http\\Response\n object. \nsetResponse()\n sets\nan individual response to always return from any request; \naddResponse()\n allows\naggregating a sequence of responses. In both cases, responses are returned\nwithout performing actual HTTP requests.\n\n\nTesting against a single HTTP response stub\n\n\nuse Zend\\Http\\Client;\n\n// Instantiate a new adapter and client\n$adapter = new Client\\Adapter\\Test();\n$client  = new Client(\n    'http://www.example.com',\n    ['adapter' => $adapter]\n);\n\n// Set the expected response\n$adapter->setResponse(\n    \"HTTP/1.1 200 OK\\r\\n\"\n    . \"Content-type: text/xml\\r\\n\"\n    . \"\\r\\n\"\n    . '<?xml version=\"1.0\" encoding=\"UTF-8\"?>'\n    . '<rss version=\"2.0\" '\n    . '     xmlns:content=\"http://purl.org/rss/1.0/modules/content/\"'\n    . '     xmlns:wfw=\"http://wellformedweb.org/CommentAPI/\"'\n    . '     xmlns:dc=\"http://purl.org/dc/elements/1.1/\">'\n    . '  <channel>'\n    . '    <title>Premature Optimization</title>'\n    // and so on...\n    . '</rss>'\n);\n\n$response = $client->send();\n// .. continue parsing $response..\n\n\n\nThe above example shows how you can preset your HTTP client to return the\nresponse you need. Then, you can continue testing your own code, without being\ndependent on a network connection, the server's response, etc. In this case, the\ntest would continue to check how the application parses the XML in the response\nbody.\n\n\nSometimes, a single method call to an object can result in that object\nperforming multiple HTTP transactions. In this case, it's not possible to use\n\nsetResponse()\n alone because there's no opportunity to set the next response(s)\nyour program might need before returning to the caller.\n\n\nTesting Against Multiple HTTP Response Stubs\n\n\nuse Zend\\Http\\Client;\n\n// Instantiate a new adapter and client\n$adapter = new Client\\Adapter\\Test();\n$client = new Client(\n    'http://www.example.com',\n    ['adapter' => $adapter]\n);\n\n// Set the first expected response\n$adapter->setResponse(\n    \"HTTP/1.1 302 Found\\r\\n\"\n    . \"Location: /\\r\\n\"\n    . \"Content-Type: text/html\\r\\n\"\n    . \"\\r\\n\"\n    . '<html>'\n    . '  <head><title>Moved</title></head>'\n    . '  <body><p>This page has moved.</p></body>'\n    . '</html>'\n);\n\n// Set the next successive response\n$adapter->addResponse(\n    \"HTTP/1.1 200 OK\\r\\n\"\n    . \"Content-Type: text/html\\r\\n\"\n    . \"\\r\\n\"\n    . '<html>'\n    . '  <head><title>My Pet Store Home Page</title></head>'\n    . '  <body><p>...</p></body>'\n    . '</html>'\n);\n\n// inject the http client object ($client) into your object\n// being tested and then test your object's behavior below\n\n\n\nThe \nsetResponse()\n method clears any responses in the adapter's buffer and sets\nthe first response that will be returned. The \naddResponse()\n method will add\nsuccessive responses.\n\n\nThe responses will be replayed in the order that they were added. If more\nrequests are made than the number of responses stored, the responses will cycle\nagain in order.\n\n\nIn the example above, the adapter is configured to test your object's behavior\nwhen it encounters a 302 redirect. Depending on your application, following a\nredirect may or may not be desired behavior. In our example, we expect that the\nredirect will be followed and we configure the test adapter to help us test\nthis. The initial 302 response is set up with the \nsetResponse()\n method and the\n200 response to be returned next is added with the \naddResponse()\n method. After\nconfiguring the test adapter, inject the HTTP client containing the adapter into\nyour object under test and test its behavior.\n\n\nForcing the adapter to fail\n\n\nIf you need the adapter to fail on demand you can use\n\nsetNextRequestWillFail($flag)\n. The method will cause the next call to\n\nconnect()\n to throw an \nZend\\Http\\Client\\Adapter\\Exception\\RuntimeException\n.\nThis can be useful when our application caches content from an external site (in\ncase the site goes down) and you want to test this feature.\n\n\nuse Zend\\Http\\Client;\n\n// Instantiate a new adapter and client\n$adapter = new Client\\Adapter\\Test();\n$client  = new Client(\n    'http://www.example.com',\n    ['adapter' => $adapter]\n);\n\n// Force the next request to fail with an exception\n$adapter->setNextRequestWillFail(true);\n\ntry {\n    // This call will result in an exception.\n    $client->send();\n} catch (Client\\Adapter\\Exception\\RuntimeException $e) {\n    // ...\n}\n\n// Further requests will work as expected until\n// you call setNextRequestWillFail(true) again\n\n\n\nCreating your own connection adapters\n\n\nZend\\Http\\Client\n has been designed so that you can create and use your own\nconnection adapters. You could, for example, create a connection adapter that\nuses persistent sockets, or a connection adapter with caching abilities, and use\nthem as needed in your application.\n\n\nIn order to do so, you must create your own adapter class that implements\n\nZend\\Http\\Client\\Adapter\\AdapterInterface\n. The following example shows the\nskeleton of a user-implemented adapter class. All the public functions defined\nin this example must be defined in your adapter as well.\n\n\nnamespace MyApp\\Http\\Client\\Adapter;\n\nuse Zend\\Http\\Client\\Adapter\\AdapterInterface;\n\nclass BananaProtocol implements AdapterInterface\n{\n    /**\n     * Set Adapter Options\n     *\n     * @param array $config\n     */\n    public function setOptions($config = [])\n    {\n        // This rarely changes - you should usually copy the\n        // implementation in Zend\\Http\\Client\\Adapter\\Socket.\n    }\n\n    /**\n     * Connect to the remote server\n     *\n     * @param string  $host\n     * @param int     $port\n     * @param boolean $secure\n     */\n    public function connect($host, $port = 80, $secure = false)\n    {\n        // Set up the connection to the remote server\n    }\n\n    /**\n     * Send request to the remote server\n     *\n     * @param string        $method\n     * @param Zend\\Uri\\Http $url\n     * @param string        $http_ver\n     * @param array         $headers\n     * @param string        $body\n     * @return string Request as text\n     */\n    public function write(\n        $method,\n        $url,\n        $http_ver = '1.1',\n        $headers = [],\n        $body = ''\n    ) {\n        // Send request to the remote server.\n        // This function is expected to return the full request\n        // (headers and body) as a string\n    }\n\n    /**\n     * Read response from server\n     *\n     * @return string\n     */\n    public function read()\n    {\n        // Read response from remote server and return it as a string\n    }\n\n    /**\n     * Close the connection to the server\n     *\n     */\n    public function close()\n    {\n        // Close the connection to the remote server - called last.\n    }\n}\n\n\n\nUse the adapter as you would any other:\n\n\nuse MyApp\\Http\\Client\\Adapter\\BananaProtocol;\nuse Zend\\Http\\Client;\n\n$client = new Client([\n    'adapter' => BananaProtocol::class,\n]);",
            "title": "Adapters"
        },
        {
            "location": "/client/adapters/#http-client-connection-adapters",
            "text": "Zend\\Http\\Client  is based on a connection adapter design. The connection adapter is the object in\ncharge of performing the actual connection to the server, as well as writing requests and reading\nresponses. This connection adapter can be replaced, and you can create and extend the default\nconnection adapters to suit your special needs, without the need to extend or replace the entire\nHTTP client class.  Currently, zend-http provides four built-in client connection adapters:   Zend\\Http\\Client\\Adapter\\Socket  (default)  Zend\\Http\\Client\\Adapter\\Proxy  Zend\\Http\\Client\\Adapter\\Curl  Zend\\Http\\Client\\Adapter\\Test   The client can accept an adapter via either its  setAdapter()  method, or during\ninstantiation via its  adapter  configuration option. When using configuration,\nthe value of the  adapter  option may be one of:   an adapter instance  the fully qualified class name of an adapter",
            "title": "HTTP Client Connection Adapters"
        },
        {
            "location": "/client/adapters/#the-socket-adapter",
            "text": "The default connection adapter used when none is specified is the Zend\\Http\\Client\\Adapter\\Socket  adapter.  The  Socket  adapter is based on\nPHP's built-in  fsockopen()  function, and does not require any special\nextensions or compilation flags.  The  Socket  adapter allows several extra configuration options that can be set\nvia either the client's constructor or  setOptions()  method:     Parameter  Description  Expected Type  Default Value      persistent  Whether to use persistent TCP connections  boolean  FALSE    ssltransport  SSL transport layer (eg.  sslv2 ,  tls )  string  ssl    sslcert  Path to a PEM encoded SSL certificate  string  NULL    sslpassphrase  Passphrase for the SSL certificate file  string  NULL    sslverifypeer  Whether to verify the SSL peer  string  TRUE    sslcapath  Path to SSL certificate directory  string  NULL    sslallowselfsigned  Whether to allow self-signed certificates  string  FALSE    sslusecontext  Enables proxied connections to use SSL even if the proxy connection itself does not.  boolean  FALSE",
            "title": "The Socket adapter"
        },
        {
            "location": "/client/adapters/#persistent-tcp-connections",
            "text": "Using persistent TCP connections can potentially speed up HTTP requests, but\nin most use cases, will have little positive effect and might overload the\nHTTP server you are connecting to. It is recommended to use persistent TCP\nconnections only if you connect to the same server very frequently, and are\nsure that the server is capable of handling a large number of concurrent\nconnections. In any case you are encouraged to benchmark the effect of\npersistent connections on both the client speed and server load before using\nthis option.  Additionally, when using persistent connections, we recommend enabling\nKeep-Alive HTTP requests as described in  the client configuration section ;\notherwise persistent connections might have little or no effect.",
            "title": "Persistent TCP connections"
        },
        {
            "location": "/client/adapters/#https-ssl-stream-parameters",
            "text": "ssltransport ,  sslcert  and  sslpassphrase  are only relevant when\nconnecting using HTTPS.  While the default SSL/TLS settings should work for\nmost applications, you might need to change them if the server you are\nconnecting to requires special client setup. If so, please read the PHP manual chapter on SSL and TLS transport options .",
            "title": "HTTPS SSL stream parameters"
        },
        {
            "location": "/client/adapters/#changing-the-https-transport-layer",
            "text": "use Zend\\Http\\Client;\n\n// Set the configuration parameters\n$config = [\n    'adapter'      => Client\\Adapter\\Socket::class,\n    'ssltransport' => 'tls',\n];\n\n// Instantiate a client object\n$client = new Client('https://www.example.com', $config);\n\n// The following request will be sent over a TLS secure connection.\n$response = $client->send();  The result of the example above will be similar to opening a TCP connection\nusing the following PHP command:  fsockopen('tls://www.example.com', 443);",
            "title": "Changing the HTTPS transport layer"
        },
        {
            "location": "/client/adapters/#customizing-and-accessing-the-socket-adapter-stream-context",
            "text": "Zend\\Http\\Client\\Adapter\\Socket  provides direct access to the underlying stream context  used to connect to the remote\nserver. This allows the user to pass specific options and parameters to the TCP\nstream, and to the SSL wrapper in case of HTTPS connections.  You can access the stream context using the following methods of Zend\\Http\\Client\\Adapter\\Socket :   setStreamContext($context) : Sets the stream context to be used by the\n  adapter. Can accept either a stream context resource created using the\n   stream_context_create()  PHP function,\n  or an array of stream context options, in the same format provided to this\n  function.  Providing an array will create a new stream context using these\n  options, and set it.  getStreamContext() : Get the current stream context of the adapter. If no\n  stream context was set, this method will create a default stream context and\n  return it. You can then set or get the value of different context options\n  using regular PHP stream context functions.",
            "title": "Customizing and accessing the Socket adapter stream context"
        },
        {
            "location": "/client/adapters/#setting-stream-context-options-for-the-socket-adapter",
            "text": "use Zend\\Http\\Client;\n\n// Array of options\n$options = [\n    'socket' => [\n        // Bind local socket side to a specific interface\n        'bindto' => '10.1.2.3:50505',\n    ],\n    'ssl'    => [\n        // Verify server side certificate,\n        // do not accept invalid or self-signed SSL certificates\n        'verify_peer'       => true,\n        'allow_self_signed' => false,\n\n        // Capture the peer's certificate\n        'capture_peer_cert' => true,\n    ],\n];\n\n// Create an adapter object and attach it to the HTTP client:\n$adapter = new Client\\Adapter\\Socket();\n$client  = new Client();\n$client->setAdapter($adapter);\n\n// Method 1: pass the options array to setStreamContext():\n$adapter->setStreamContext($options);\n\n// Method 2: create a stream context and pass it to setStreamContext():\n$context = stream_context_create($options);\n$adapter->setStreamContext($context);\n\n// Method 3: get the default stream context and set the options on it:\n$context = $adapter->getStreamContext();\nstream_context_set_option($context, $options);\n\n// Now, perform the request:\n$response = $client->send();\n\n// If everything went well, you can now access the context again:\n$opts = stream_context_get_options($adapter->getStreamContext());\necho $opts['ssl']['peer_certificate'];",
            "title": "Setting stream context options for the Socket adapter"
        },
        {
            "location": "/client/adapters/#set-stream-context-options-prior-to-requests",
            "text": "Note that you must set any stream context options before using the adapter to\nperform actual requests. If no context is set before performing HTTP requests\nwith the  Socket  adapter, a default stream context will be created. This\ncontext resource could be accessed after performing any requests using the getStreamContext()  method.",
            "title": "Set stream context options prior to requests"
        },
        {
            "location": "/client/adapters/#the-proxy-adapter",
            "text": "Zend\\Http\\Client\\Adapter\\Proxy  is similar to the default  Socket  adapter; the\nprimary difference is that the connection is made through an HTTP proxy server\ninstead of a direct connection to the target server. This allows usage of Zend\\Http\\Client  behind proxy servers, which is sometimes required for\nsecurity or performance reasons.  Using the  Proxy  adapter requires several additional client configuration\nparameters to be set, in addition to the default  adapter  option:     Parameter  Description  Expected Type  Example Value      proxy_host  Proxy server address  string  'proxy.myhost.com'\u2019 or '10.1.2.3'    proxy_port  Proxy server TCP port  integer  8080 (default) or 81    proxy_user  Proxy user name, if required  string  'shahar' or '' for none (default)    proxy_pass  Proxy password, if required  string  'secret' or '' for none (default)    proxy_auth  Proxy HTTP authentication type  string  Zend\\Http\\Client::AUTH_BASIC  (default)     proxy_host  should always be set; if it is not set, the client will fall back\nto a direct connection using  Zend\\Http\\Client\\Adapter\\Socket .  proxy_port \ndefaults to '8080'; if your proxy listens on a different port, you must set this\none as well.  proxy_user  and  proxy_pass  are only required if your proxy server requires\nyou to authenticate.  Providing these will add a 'Proxy-Authentication' header\nto the request. If your proxy does not require authentication, you can leave\nthese two options out.  proxy_auth  sets the proxy authentication type, if your proxy server requires\nauthentication.  Possible values are similar to the ones accepted by the Zend\\Http\\Client::setAuth()  method. Currently, only basic authentication\n( Zend\\Http\\Client::AUTH_BASIC ) is supported.",
            "title": "The Proxy adapter"
        },
        {
            "location": "/client/adapters/#using-zend92http92client-behind-a-proxy-server",
            "text": "use Zend\\Http\\Client;\n\n// Set the configuration parameters\n$config = [\n    'adapter'    => Client\\Adapter\\Proxy::class,\n    'proxy_host' => 'proxy.int.zend.com',\n    'proxy_port' => 8000,\n    'proxy_user' => 'shahar.e',\n    'proxy_pass' => 'bananashaped',\n];\n\n// Instantiate a client object\n$client = new Client('http://www.example.com', $config);\n\n// Continue working...  As mentioned, if  proxy_host  is not set or is set to a blank string, the\nconnection will fall back to a regular direct connection. This allows you to\nwrite your application in a way that allows a proxy to be used optionally,\naccording to a configuration parameter.",
            "title": "Using Zend\\Http\\Client behind a proxy server"
        },
        {
            "location": "/client/adapters/#access-to-stream-context",
            "text": "Since the proxy adapter inherits from  Zend\\Http\\Client\\Adapter\\Socket , you\ncan use the stream context access method (see above ) to set stream\ncontext options on  Proxy  connections.",
            "title": "Access to stream context"
        },
        {
            "location": "/client/adapters/#the-curl-adapter",
            "text": "cURL is a standard HTTP client library that is distributed with many operating\nsystems and can be used in PHP via the cURL extension. It offers functionality\nfor many special cases which can occur for a HTTP client and make it a perfect\nchoice for a HTTP adapter. It supports secure connections, proxies, and multiple\nauthentication mechanisms. In particular, it is very performant with regards to\ntransfering large files.",
            "title": "The cURL Adapter"
        },
        {
            "location": "/client/adapters/#setting-curl-options",
            "text": "use Zend\\Http\\Client;\n\n$config = [\n    'adapter'     => Client\\Adapter\\Curl::class,\n    'curloptions' => [CURLOPT_FOLLOWLOCATION => true],\n];\n$client = new Client($uri, $config);  By default, the cURL adapter is configured to behave exactly like the  Socket \nadapter, and it also accepts the same configuration parameters as the  Socket \nand  Proxy  adapters. You can also change the cURL options by either specifying\nthe 'curloptions' key in the constructor of the adapter, or by calling setCurlOption($name, $value) ; option names correspond to the  CURL_* \nconstants of the cURL extension. You can get access to the underling cURL handle\nby calling  $adapter->getHandle();  The cURL configuration options that can be set via  setCurlOption($name, $value) \nmethod are:     Parameter  Description  Expected Type  Default Value      proxyuser  Whether to use persistent TCP connections  boolean  FALSE    proxypass  SSL transport layer (eg.  sslv2 ,  tls )  string  ssl    proxyhost  Path to a PEM encoded SSL certificate  string  NULL    proxyport  Passphrase for the SSL certificate file  string  NULL    sslverifypeer  Whether to verify the SSL peer  string  TRUE",
            "title": "Setting cURL options"
        },
        {
            "location": "/client/adapters/#transfering-files-by-handle",
            "text": "You can use cURL to transfer very large files over HTTP by filehandle.  use Zend\\Http\\Client;\n\n$putFileSize   = filesize('filepath');\n$putFileHandle = fopen('filepath', 'r');\n\n$adapter = new Client\\Adapter\\Curl();\n$client = new Client();\n$client->setAdapter($adapter);\n$client->setMethod('PUT');\n$adapter->setOptions([\n    'curloptions' => [\n        CURLOPT_INFILE     => $putFileHandle,\n        CURLOPT_INFILESIZE => $putFileSize,\n    ],\n]);\n$client->send();",
            "title": "Transfering files by handle"
        },
        {
            "location": "/client/adapters/#the-test-adapter",
            "text": "Testing code that relies on HTTP connections poses difficulties.  For example,\ntesting an application that pulls an RSS feed from a remote server will require\na network connection, which is not always available.  Zend\\Http\\Client\\Adapter\\Test  provides a solution for these situations and\nacts as a mock object for unit tests. You can write your application to use Zend\\Http\\Client , and, when testing (either in your unit test suite, or in\nnon-production environments), replace the default adapter with the test adapter,\nallowing you to run tests without actually performing server connections.  Zend\\Http\\Client\\Adapter\\Test  provides two additional methods,  setResponse() \nand  addResponse() .  Each takes one parameter, which represents an HTTP\nresponse as either text or a  Zend\\Http\\Response  object.  setResponse()  sets\nan individual response to always return from any request;  addResponse()  allows\naggregating a sequence of responses. In both cases, responses are returned\nwithout performing actual HTTP requests.",
            "title": "The Test adapter"
        },
        {
            "location": "/client/adapters/#testing-against-a-single-http-response-stub",
            "text": "use Zend\\Http\\Client;\n\n// Instantiate a new adapter and client\n$adapter = new Client\\Adapter\\Test();\n$client  = new Client(\n    'http://www.example.com',\n    ['adapter' => $adapter]\n);\n\n// Set the expected response\n$adapter->setResponse(\n    \"HTTP/1.1 200 OK\\r\\n\"\n    . \"Content-type: text/xml\\r\\n\"\n    . \"\\r\\n\"\n    . '<?xml version=\"1.0\" encoding=\"UTF-8\"?>'\n    . '<rss version=\"2.0\" '\n    . '     xmlns:content=\"http://purl.org/rss/1.0/modules/content/\"'\n    . '     xmlns:wfw=\"http://wellformedweb.org/CommentAPI/\"'\n    . '     xmlns:dc=\"http://purl.org/dc/elements/1.1/\">'\n    . '  <channel>'\n    . '    <title>Premature Optimization</title>'\n    // and so on...\n    . '</rss>'\n);\n\n$response = $client->send();\n// .. continue parsing $response..  The above example shows how you can preset your HTTP client to return the\nresponse you need. Then, you can continue testing your own code, without being\ndependent on a network connection, the server's response, etc. In this case, the\ntest would continue to check how the application parses the XML in the response\nbody.  Sometimes, a single method call to an object can result in that object\nperforming multiple HTTP transactions. In this case, it's not possible to use setResponse()  alone because there's no opportunity to set the next response(s)\nyour program might need before returning to the caller.",
            "title": "Testing against a single HTTP response stub"
        },
        {
            "location": "/client/adapters/#testing-against-multiple-http-response-stubs",
            "text": "use Zend\\Http\\Client;\n\n// Instantiate a new adapter and client\n$adapter = new Client\\Adapter\\Test();\n$client = new Client(\n    'http://www.example.com',\n    ['adapter' => $adapter]\n);\n\n// Set the first expected response\n$adapter->setResponse(\n    \"HTTP/1.1 302 Found\\r\\n\"\n    . \"Location: /\\r\\n\"\n    . \"Content-Type: text/html\\r\\n\"\n    . \"\\r\\n\"\n    . '<html>'\n    . '  <head><title>Moved</title></head>'\n    . '  <body><p>This page has moved.</p></body>'\n    . '</html>'\n);\n\n// Set the next successive response\n$adapter->addResponse(\n    \"HTTP/1.1 200 OK\\r\\n\"\n    . \"Content-Type: text/html\\r\\n\"\n    . \"\\r\\n\"\n    . '<html>'\n    . '  <head><title>My Pet Store Home Page</title></head>'\n    . '  <body><p>...</p></body>'\n    . '</html>'\n);\n\n// inject the http client object ($client) into your object\n// being tested and then test your object's behavior below  The  setResponse()  method clears any responses in the adapter's buffer and sets\nthe first response that will be returned. The  addResponse()  method will add\nsuccessive responses.  The responses will be replayed in the order that they were added. If more\nrequests are made than the number of responses stored, the responses will cycle\nagain in order.  In the example above, the adapter is configured to test your object's behavior\nwhen it encounters a 302 redirect. Depending on your application, following a\nredirect may or may not be desired behavior. In our example, we expect that the\nredirect will be followed and we configure the test adapter to help us test\nthis. The initial 302 response is set up with the  setResponse()  method and the\n200 response to be returned next is added with the  addResponse()  method. After\nconfiguring the test adapter, inject the HTTP client containing the adapter into\nyour object under test and test its behavior.",
            "title": "Testing Against Multiple HTTP Response Stubs"
        },
        {
            "location": "/client/adapters/#forcing-the-adapter-to-fail",
            "text": "If you need the adapter to fail on demand you can use setNextRequestWillFail($flag) . The method will cause the next call to connect()  to throw an  Zend\\Http\\Client\\Adapter\\Exception\\RuntimeException .\nThis can be useful when our application caches content from an external site (in\ncase the site goes down) and you want to test this feature.  use Zend\\Http\\Client;\n\n// Instantiate a new adapter and client\n$adapter = new Client\\Adapter\\Test();\n$client  = new Client(\n    'http://www.example.com',\n    ['adapter' => $adapter]\n);\n\n// Force the next request to fail with an exception\n$adapter->setNextRequestWillFail(true);\n\ntry {\n    // This call will result in an exception.\n    $client->send();\n} catch (Client\\Adapter\\Exception\\RuntimeException $e) {\n    // ...\n}\n\n// Further requests will work as expected until\n// you call setNextRequestWillFail(true) again",
            "title": "Forcing the adapter to fail"
        },
        {
            "location": "/client/adapters/#creating-your-own-connection-adapters",
            "text": "Zend\\Http\\Client  has been designed so that you can create and use your own\nconnection adapters. You could, for example, create a connection adapter that\nuses persistent sockets, or a connection adapter with caching abilities, and use\nthem as needed in your application.  In order to do so, you must create your own adapter class that implements Zend\\Http\\Client\\Adapter\\AdapterInterface . The following example shows the\nskeleton of a user-implemented adapter class. All the public functions defined\nin this example must be defined in your adapter as well.  namespace MyApp\\Http\\Client\\Adapter;\n\nuse Zend\\Http\\Client\\Adapter\\AdapterInterface;\n\nclass BananaProtocol implements AdapterInterface\n{\n    /**\n     * Set Adapter Options\n     *\n     * @param array $config\n     */\n    public function setOptions($config = [])\n    {\n        // This rarely changes - you should usually copy the\n        // implementation in Zend\\Http\\Client\\Adapter\\Socket.\n    }\n\n    /**\n     * Connect to the remote server\n     *\n     * @param string  $host\n     * @param int     $port\n     * @param boolean $secure\n     */\n    public function connect($host, $port = 80, $secure = false)\n    {\n        // Set up the connection to the remote server\n    }\n\n    /**\n     * Send request to the remote server\n     *\n     * @param string        $method\n     * @param Zend\\Uri\\Http $url\n     * @param string        $http_ver\n     * @param array         $headers\n     * @param string        $body\n     * @return string Request as text\n     */\n    public function write(\n        $method,\n        $url,\n        $http_ver = '1.1',\n        $headers = [],\n        $body = ''\n    ) {\n        // Send request to the remote server.\n        // This function is expected to return the full request\n        // (headers and body) as a string\n    }\n\n    /**\n     * Read response from server\n     *\n     * @return string\n     */\n    public function read()\n    {\n        // Read response from remote server and return it as a string\n    }\n\n    /**\n     * Close the connection to the server\n     *\n     */\n    public function close()\n    {\n        // Close the connection to the remote server - called last.\n    }\n}  Use the adapter as you would any other:  use MyApp\\Http\\Client\\Adapter\\BananaProtocol;\nuse Zend\\Http\\Client;\n\n$client = new Client([\n    'adapter' => BananaProtocol::class,\n]);",
            "title": "Creating your own connection adapters"
        },
        {
            "location": "/client/static/",
            "text": "HTTP Client - Static Usage\n\n\nzend-http provides another client implementation, \nZend\\Http\\ClientStatic\n, a\nstatic HTTP client which exposes a simplified API for quickly performing one-off \nGET\n\nand \nPOST\n operations.\n\n\nQuick Start\n\n\nuse Zend\\Http\\ClientStatic;\n\n// Simple GET request\n$response = ClientStatic::get('http://example.org');\n\n// More complex GET request, specifying query string 'foo=bar' and adding a\n// custom header to request JSON data be returned (Accept: application/json):\n$response = ClientStatic::get(\n    'http://example.org',\n    ['foo' => 'bar'],\n    ['Accept' => 'application/json']\n);\n\n// We can also do a POST request using the same format. Here we POST\n// login credentials (username/password) to a login page:\n$response = ClientStatic::post(\n    'https://example.org/login.php',\n    [\n        'username' => 'foo',\n        'password' => 'bar',\n    ]\n);\n\n\n\nAvailable Methods\n\n\nget()\n\n\nget(\n    string $url,\n    array $query = [],\n    array $headers = [],\n    mixed $body = null,\n    $clientOptions = null\n) : Response\n\n\n\nPerform an HTTP \nGET\n request using the provided URL, query string variables,\nheaders, and request body. The fifth parameter can be used to pass configuration\noptions to the HTTP client instance.\n\n\npost()\n\n\npost(\n    string $url,\n    array $params,\n    array $headers = [],\n    mixed $body = null,\n    $clientOptions = null\n) : Response\n\n\n\nPerform an HTTP \nPOST\n request using the provided URL, parameters, headers, and\nrequest body. The fifth parameter can be used to pass configuration options to\nthe HTTP client instance.",
            "title": "Static Client"
        },
        {
            "location": "/client/static/#http-client-static-usage",
            "text": "zend-http provides another client implementation,  Zend\\Http\\ClientStatic , a\nstatic HTTP client which exposes a simplified API for quickly performing one-off  GET \nand  POST  operations.",
            "title": "HTTP Client - Static Usage"
        },
        {
            "location": "/client/static/#quick-start",
            "text": "use Zend\\Http\\ClientStatic;\n\n// Simple GET request\n$response = ClientStatic::get('http://example.org');\n\n// More complex GET request, specifying query string 'foo=bar' and adding a\n// custom header to request JSON data be returned (Accept: application/json):\n$response = ClientStatic::get(\n    'http://example.org',\n    ['foo' => 'bar'],\n    ['Accept' => 'application/json']\n);\n\n// We can also do a POST request using the same format. Here we POST\n// login credentials (username/password) to a login page:\n$response = ClientStatic::post(\n    'https://example.org/login.php',\n    [\n        'username' => 'foo',\n        'password' => 'bar',\n    ]\n);",
            "title": "Quick Start"
        },
        {
            "location": "/client/static/#available-methods",
            "text": "",
            "title": "Available Methods"
        },
        {
            "location": "/client/static/#get",
            "text": "get(\n    string $url,\n    array $query = [],\n    array $headers = [],\n    mixed $body = null,\n    $clientOptions = null\n) : Response  Perform an HTTP  GET  request using the provided URL, query string variables,\nheaders, and request body. The fifth parameter can be used to pass configuration\noptions to the HTTP client instance.",
            "title": "get()"
        },
        {
            "location": "/client/static/#post",
            "text": "post(\n    string $url,\n    array $params,\n    array $headers = [],\n    mixed $body = null,\n    $clientOptions = null\n) : Response  Perform an HTTP  POST  request using the provided URL, parameters, headers, and\nrequest body. The fifth parameter can be used to pass configuration options to\nthe HTTP client instance.",
            "title": "post()"
        },
        {
            "location": "/client/cookies/",
            "text": "Client Cookies\n\n\nZend\\Http\\Cookies\n can be used with \nZend\\Http\\Client\n to manage sending\ncookies in the request and setting cookies from the response; it is populated\nfrom the \nSet-Cookie\n headers obtained from a client response, and then used to\npopulate the \nCookie\n headers for a client request. This is highly useful in\ncases where you need to maintain a user session over consecutive HTTP requests,\nautomatically sending the session ID cookies when required. Additionally, the\n\nZend\\Http\\Cookies\n object can be serialized and stored in \n$_SESSION\n when\nneeded.\n\n\nZend\\Http\\Client\n already provides methods for managing cookies for requests;\n\nZend\\Http\\Cookies\n manages the parsing of \nSet-Cookie\n headers returned in the\nresponse, and allows persisting them. Additionally, \nCookies\n can return a\nsubset of cookies that match the current request, ensuring you are only sending\nrelevant cookies.\n\n\nUsage\n\n\nCookies\n is an extension of \nZend\\Http\\Headers\n, and inherits its methods. It\ncan be instantiated without any arguments.\n\n\nuse Zend\\Http\\Cookies;\n\n$cookies = new Cookies();\n\n\n\nOn your first client request, you likely won't have any cookies, so the\ninstance does nothing.\n\n\nOnce you've made your first request, you can start using it. Populate it from\nthe response:\n\n\n$response = $client->send();\n\n$cookies->addCookiesFromResponse($response, $client->getUri());\n\n\n\nAlternately, you can create your initial \nCookies\n instance using the static \nfromResponse()\n method:\n\n\n$cookies = Cookies::fromResponse($response, $client->getUri());\n\n\n\nOn subsequent requests, we'll notify the client of our cookies. To do this, we\nshould use the same URI we'll use for the request.\n\n\n$client->setUri($uri);\n$client->setCookies($cookies->getMatchingCookies($uri));\n\n\n\nAfter the request, don't forget to add any cookies returned!\n\n\nEssentially, \nCookies\n aggregates all cookies for our client interactions, and\nallows us to send only those relevant to a given request.\n\n\nSerializing and caching cookies\n\n\nTo cache cookies \u2014 e.g., to store in \n$_SESSION\n, or between job\ninvocations \u2014 you will need to serialize them. \nZend\\Http\\Cookies\n\nprovides this functionality via the \ngetAllCookies()\n method.\n\n\nIf your cache storage allows array structures, use the \nCOOKIE_STRING_ARRAY\n constant:\n\n\n$cookiesToCache = $cookies->getAllCookies($cookies::COOKIE_STRING_ARRAY);\n\n\n\nIf your cache storage only allows string values, use \nCOOKIE_STRING_CONCAT\n:\n\n\n$cookiesToCache = $cookies->getAllCookies($cookies::COOKIE_STRING_CONCAT);\n\n\n\nWhen you retrieve the value later, you can test its type to determine how to\ndeserialize the values:\n\n\nuse Zend\\Http\\Cookies;\nuse Zend\\Http\\Headers;\n\n$cookies = new Cookies();\n\nif (is_array($cachedCookies)) {\n    foreach ($cachedCookies as $cookie) {\n        $cookies->addCookie($cookie);\n    }\n} elseif (is_string($cachedCookies)) {\n    foreach (Headers::fromString($cachedCookies) as $cookie) {\n        $cookies->addCookie($cookie);\n    }\n}\n\n\n\nPublic methods\n\n\nBesides the methods demonstrated in the examples, \nZend\\Http\\Cookies\n defines the following:\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstatic fromResponse(Response $response, string $refUri) : Cookies\n\n\nCreate a \nCookies\n instance from a response and the request URI. Parses all \nSet-Cookie\n headers, maps them to the URI, and aggregates them.\n\n\n\n\n\n\naddCookie(string|SetCookie $cookie, string $refUri = null) : void\n\n\nAdd a cookie, mapping it to the given URI. If no URI is provided, it will be inferred from the cookie value's domain and path.\n\n\n\n\n\n\naddCookiesFromResponse(Response $response, string $refUri) : void\n\n\nAdd all \nSet-Cookie\n values from the provided response, mapping to the given URI.\n\n\n\n\n\n\ngetAllCookies(int $retAs = self::COOKIE_OBJECT) : array|string\n\n\nRetrieve all cookies. Returned array will have either \nSetCookie\n instances (the default), strings for each \nSet-Cookie\n declaration, or a single string containing all declarations, based on the \nCOOKIE_*\n constant used.\n\n\n\n\n\n\ngetCookie(/* ... */) : string|SetCookie\n\n\nRetrieve a single cookie by name for the given URI. See below for argument details.\n\n\n\n\n\n\ngetMatchingCookies(/* ... */) : array\n\n\nSee below for details.\n\n\n\n\n\n\nisEmpty() : bool\n\n\nWhether or not the instance aggregates any cookies currently.\n\n\n\n\n\n\nreset() : void\n\n\nClear all aggregated cookies from the instance.\n\n\n\n\n\n\n\n\ngetCookie()\n accepts the following arguments, in the following order:\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstring $uri\n\n\nURI to match when retrieving the cookie. Will use its protocol, domain, and path.\n\n\n\n\n\n\nstring $cookieName\n\n\nThe specific cookie name to retrieve.\n\n\n\n\n\n\nint $retAs = self::COOKIE_OBJECT\n\n\nHow to return matched cookies; defaults to \nSetCookie\n objects. Can be any of the \nCookies::COOKIE_*\n constant values.\n\n\n\n\n\n\n\n\ngetMatchingCookies()\n accepts the following arguments, in the following order:\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstring $uri\n\n\nURI to match when retrieving cookies. Will use its protocol, domain, and path.\n\n\n\n\n\n\nbool $matchSessionCookies = true\n\n\nWhether or not to also return related session cookies.\n\n\n\n\n\n\nint $retAs = self::COOKIE_OBJECT\n\n\nHow to return matched cookies; defaults to \nSetCookie\n objects. Can be any of the \nCookies::COOKIE_*\n constant values.\n\n\n\n\n\n\nint $now = null\n\n\nTimestamp against which to match; defaults to \ntime()\n. Any expired cookies will be ignored.",
            "title": "Cookie Persistence"
        },
        {
            "location": "/client/cookies/#client-cookies",
            "text": "Zend\\Http\\Cookies  can be used with  Zend\\Http\\Client  to manage sending\ncookies in the request and setting cookies from the response; it is populated\nfrom the  Set-Cookie  headers obtained from a client response, and then used to\npopulate the  Cookie  headers for a client request. This is highly useful in\ncases where you need to maintain a user session over consecutive HTTP requests,\nautomatically sending the session ID cookies when required. Additionally, the Zend\\Http\\Cookies  object can be serialized and stored in  $_SESSION  when\nneeded.  Zend\\Http\\Client  already provides methods for managing cookies for requests; Zend\\Http\\Cookies  manages the parsing of  Set-Cookie  headers returned in the\nresponse, and allows persisting them. Additionally,  Cookies  can return a\nsubset of cookies that match the current request, ensuring you are only sending\nrelevant cookies.",
            "title": "Client Cookies"
        },
        {
            "location": "/client/cookies/#usage",
            "text": "Cookies  is an extension of  Zend\\Http\\Headers , and inherits its methods. It\ncan be instantiated without any arguments.  use Zend\\Http\\Cookies;\n\n$cookies = new Cookies();  On your first client request, you likely won't have any cookies, so the\ninstance does nothing.  Once you've made your first request, you can start using it. Populate it from\nthe response:  $response = $client->send();\n\n$cookies->addCookiesFromResponse($response, $client->getUri());  Alternately, you can create your initial  Cookies  instance using the static  fromResponse()  method:  $cookies = Cookies::fromResponse($response, $client->getUri());  On subsequent requests, we'll notify the client of our cookies. To do this, we\nshould use the same URI we'll use for the request.  $client->setUri($uri);\n$client->setCookies($cookies->getMatchingCookies($uri));  After the request, don't forget to add any cookies returned!  Essentially,  Cookies  aggregates all cookies for our client interactions, and\nallows us to send only those relevant to a given request.",
            "title": "Usage"
        },
        {
            "location": "/client/cookies/#serializing-and-caching-cookies",
            "text": "To cache cookies \u2014 e.g., to store in  $_SESSION , or between job\ninvocations \u2014 you will need to serialize them.  Zend\\Http\\Cookies \nprovides this functionality via the  getAllCookies()  method.  If your cache storage allows array structures, use the  COOKIE_STRING_ARRAY  constant:  $cookiesToCache = $cookies->getAllCookies($cookies::COOKIE_STRING_ARRAY);  If your cache storage only allows string values, use  COOKIE_STRING_CONCAT :  $cookiesToCache = $cookies->getAllCookies($cookies::COOKIE_STRING_CONCAT);  When you retrieve the value later, you can test its type to determine how to\ndeserialize the values:  use Zend\\Http\\Cookies;\nuse Zend\\Http\\Headers;\n\n$cookies = new Cookies();\n\nif (is_array($cachedCookies)) {\n    foreach ($cachedCookies as $cookie) {\n        $cookies->addCookie($cookie);\n    }\n} elseif (is_string($cachedCookies)) {\n    foreach (Headers::fromString($cachedCookies) as $cookie) {\n        $cookies->addCookie($cookie);\n    }\n}",
            "title": "Serializing and caching cookies"
        },
        {
            "location": "/client/cookies/#public-methods",
            "text": "Besides the methods demonstrated in the examples,  Zend\\Http\\Cookies  defines the following:     Method signature  Description      static fromResponse(Response $response, string $refUri) : Cookies  Create a  Cookies  instance from a response and the request URI. Parses all  Set-Cookie  headers, maps them to the URI, and aggregates them.    addCookie(string|SetCookie $cookie, string $refUri = null) : void  Add a cookie, mapping it to the given URI. If no URI is provided, it will be inferred from the cookie value's domain and path.    addCookiesFromResponse(Response $response, string $refUri) : void  Add all  Set-Cookie  values from the provided response, mapping to the given URI.    getAllCookies(int $retAs = self::COOKIE_OBJECT) : array|string  Retrieve all cookies. Returned array will have either  SetCookie  instances (the default), strings for each  Set-Cookie  declaration, or a single string containing all declarations, based on the  COOKIE_*  constant used.    getCookie(/* ... */) : string|SetCookie  Retrieve a single cookie by name for the given URI. See below for argument details.    getMatchingCookies(/* ... */) : array  See below for details.    isEmpty() : bool  Whether or not the instance aggregates any cookies currently.    reset() : void  Clear all aggregated cookies from the instance.     getCookie()  accepts the following arguments, in the following order:     Argument  Description      string $uri  URI to match when retrieving the cookie. Will use its protocol, domain, and path.    string $cookieName  The specific cookie name to retrieve.    int $retAs = self::COOKIE_OBJECT  How to return matched cookies; defaults to  SetCookie  objects. Can be any of the  Cookies::COOKIE_*  constant values.     getMatchingCookies()  accepts the following arguments, in the following order:     Argument  Description      string $uri  URI to match when retrieving cookies. Will use its protocol, domain, and path.    bool $matchSessionCookies = true  Whether or not to also return related session cookies.    int $retAs = self::COOKIE_OBJECT  How to return matched cookies; defaults to  SetCookie  objects. Can be any of the  Cookies::COOKIE_*  constant values.    int $now = null  Timestamp against which to match; defaults to  time() . Any expired cookies will be ignored.",
            "title": "Public methods"
        },
        {
            "location": "/client/advanced/",
            "text": "HTTP Client Advanced Usage\n\n\nHTTP redirections\n\n\nZend\\Http\\Client\n automatically handles HTTP redirections, and by default\nwill follow up to 5 redirections. This can be changed by setting the\n\nmaxredirects\n configuration parameter.\n\n\nAccording to the HTTP/1.1 RFC, HTTP 301 and 302 responses should be treated by\nthe client by resending the same request to the specified location, using the\nsame request method. However, most clients to not implement this and always use\na \nGET\n request when redirecting. By default, \nZend\\Http\\Client\n does the same;\nwhen redirecting on a 301 or 302 response, all query and body parameters are\nreset, and a \nGET\n request is sent to the new location. This behavior can be\nchanged by setting the \nstrictredirects\n configuration parameter to boolean\n\nTRUE\n:\n\n\n// Strict Redirections\n$client->setOptions(['strictredirects' => true]);\n\n// Non-strict Redirections\n$client->setOptions(['strictredirects' => false]);\n\n\n\nYou can always get the number of redirections done after sending a request\nusing the \ngetRedirectionsCount()\n method.\n\n\nAdding cookies and using cookie persistence\n\n\nZend\\Http\\Client\n provides an interface for adding cookies to your request, so\nthat no direct header modification is required. Cookies can be added using\neither the addCookie() or \nsetCookies()\n method. \naddCookie()\n can accept\neither a name and value, a \nSetCookie\n header instance, or an array of\n\nSetCookie\n header instances.\n\n\nuse Zend\\Http\\Header\\SetCookie;\n\n// Basic usage: provide a cookie name and cookie value:\n$client->addCookie('flavor', 'chocolate chips');\n\n// Or provide a SetCookie instance:\n$cookie = SetCookie::fromString('Set-Cookie: flavor=chocolate%20chips');\n$client->addCookie($cookie);\n\n// Multiple cookies can be set at once by providing an\n// array of SetCookie instances:\n$cookies = [\n    SetCookie::fromString('Set-Cookie: flavorOne=chocolate%20chips'),\n    SetCookie::fromString('Set-Cookie: flavorTwo=vanilla'),\n];\n$client->addCookie($cookies);\n\n\n\nThe \nsetCookies()\n method works in a similar manner, except that it requires an\narray of cookie name/value pairs as its only argument, and also clears the\ncookie container before adding the new cookies:\n\n\n// setCookies accepts an array of cookie values as $name => $value\n$client->setCookies([\n    'flavor' => 'chocolate chips',\n    'amount' => 10,\n]);\n\n\n\nSee the \nHeaders documentation\n for more detail on the\n\nSetCookie\n class.\n\n\nEnabling Cookie Stickiness\n\n\nZend\\Http\\Client\n also provides a means for simplifying cookie \"stickiness\"\n\u2014 i.e., having the client internally store all sent and received cookies,\nand resending them on subsequent requests. \u2014 via the \nZend\\Http\\Cookies\n\nclass. This is useful when you need to log in to a remote site first and\nreceive an authentication or session ID cookie before sending further requests.\n\n\n$headers = $client->getRequest()->getHeaders();\n$cookies = new Zend\\Http\\Cookies($headers);\n\n// First request: log in and start a session\n$client->setUri('http://example.com/login.php');\n$client->setParameterPost(['user' => 'h4x0r', 'password' => 'l33t']);\n$client->setMethod('POST');\n\n$response = $client->getResponse();\n$cookies->addCookiesFromResponse($response, $client->getUri());\n\n// Now we can send our next request\n$client->setUri('http://example.com/read_member_news.php');\n$client->setCookies($cookies->getMatchingCookies($client->getUri()));\n$client->setMethod('GET');\n\n\n\nSee the chapter on \ncookies\n for more detail.\n\n\nSetting custom request headers\n\n\nSetting custom headers is performed by first fetching the header container from\nthe client's \nZend\\Http\\Request\n instance. This \nHeaders\n container offers a\nnumber of methods for setting headers:\n\n\nuse Zend\\Http\\Header;\n\n// Fetch the container\n$headers = $client->getRequest()->getHeaders();\n\n// Setting a single header using a name and value. Will not overwrite any //\npreviously-added headers of the same name.\n$headers->addHeaderLine('Host', 'www.example.com');\n\n// You can also use a full header line:\n$headers->addHeaderLine('Host: www.example.com');\n\n// Sometimes you may want to use a HeaderInterface instance:\n$headers->addHeader(Header\\Host::fromString('Host: www.example.com'));\n\n// You can also add multiple headers at once by passing an\n// array to addHeaders() using any of the formats below:\n$headers->addHeaders([\n    // Zend\\Http\\Header\\* instance:\n    Header\\Host::fromString('Host: www.example.com'),\n\n    // Header name/value pair:\n    'Cookie' => 'PHPSESSID=1234567890abcdef1234567890abcdef',\n\n    // Raw header string:\n    'Cookie: language=he',\n]);\n\n\n\nZend\\Http\\Client\n also provides a convenience method for setting request\nheaders, \nsetHeaders()\n.  This method will create a new header container, add\nthe specified headers, and then store the new header container in its\n\nZend\\Http\\Request\n instance. As a consequence, any pre-existing headers will\nbe erased:\n\n\nuse Zend\\Http\\Header;\n\n// Setting multiple headers via the client; removes all existing headers,\n// replacing the request header container with the following:\n$client->setHeaders([\n    Zend\\Http\\Header\\Host::fromString('Host: www.example.com'),\n    ['Accept-Encoding' => 'gzip,deflate'],\n    'X-Powered-By: Zend Framework',\n]);\n\n\n\nFile uploads\n\n\nYou can upload files through HTTP using the \nsetFileUpload()\n method. This\nmethod takes a file name as the first parameter, a form name as the second\nparameter, and data as a third optional parameter. If the third data parameter\nis \nNULL\n, the first file name parameter is considered to be a real file on\ndisk, and \nZend\\Http\\Client\n will try to read this file and upload it. If the\ndata parameter is not \nNULL\n, the first file name parameter will be sent as the\nfile name, but no actual file needs to exist on the disk. The second form name\nparameter is always required, and is equivalent to the \"name\" attribute of an\n\n<input>\n tag, if the file was to be uploaded through an HTML form. A fourth\noptional parameter provides the file's \nContent-Type\n. If not specified, and\n\nZend\\Http\\Client\n reads the file from the disk, the \nmime_content_type()\n\nfunction will be used to guess the file's content type, if it is available. In\nany case, the default MIME type will be \napplication/octet-stream\n.\n\n\n// Uploading arbitrary data as a file:\n$text = 'this is some plain text';\n$client->setFileUpload('some_text.txt', 'upload', $text, 'text/plain');\n\n// Uploading an existing file:\n$client->setFileUpload('/tmp/Backup.tar.gz', 'bufile');\n\n// Send the files:\n$client->setMethod('POST');\n$client->send();\n\n\n\nIn the first example, the \n$text\n variable is uploaded and will be available as\n\n$_FILES['upload']\n on the server side. In the second example, the existing\nfile \n/tmp/Backup.tar.gz\n is uploaded to the server and will be available as\n\n$_FILES['bufile']\n. The content type will be guessed automatically if\npossible, defaulting to \napplication/octet-stream\n.\n\n\n\n\nUploading files\n\n\nWhen uploading files, the HTTP request \nContent-Type\n is automatically set to\n\nmultipart/form-data\n.  Keep in mind that you must send a POST or PUT request\nin order to upload files; most servers will ignore the request body on other\nrequest methods.\n\n\n\n\nSending raw POST data\n\n\nYou can send raw POST data via \nZend\\Http\\Client\n using the \nsetRawBody()\n\nmethod. This method takes one parameter: the data to send in the request body.\nWhen sending raw POST data, it is advisable to also set the encoding type using\n\nsetEncType()\n.\n\n\n$xml = '<book>'\n    . '  <title>Islands in the Stream</title>'\n    . '  <author>Ernest Hemingway</author>'\n    . '  <year>1970</year>'\n    . '</book>';\n$client->setMethod('POST');\n$client->setRawBody($xml);\n$client->setEncType('text/xml');\n$client->send();\n\n\n\nThe data should be available on the server side through PHP's \nphp://input\n\nstream.\n\n\n\n\nRaw POST data overrides other content\n\n\nSetting raw POST data for a request will override any POST parameters or file\nuploads; you should not try to use both on the same request. Keep in mind\nthat most servers will ignore the request body unless you send a POST\nrequest.\n\n\n\n\nHTTP authentication\n\n\nCurrently, \nZend\\Http\\Client\n only supports basic HTTP authentication. This feature is utilized\nusing the \nsetAuth()\n method, or by specifying a username and a password in the URI. The \nsetAuth()\n\nmethod takes 3 parameters: the user name, the password and an optional authentication type\nparameter.\n\n\nuse Zend\\Http\\Client;\n\n// Using basic authentication\n$client->setAuth('shahar', 'myPassword!', Client::AUTH_BASIC);\n\n// Since basic auth is default, you can just do this:\n$client->setAuth('shahar', 'myPassword!');\n\n// You can also specify username and password in the URI\n$client->setUri('http://christer:secret@example.com');\n\n\n\nSending multiple requests with the same client\n\n\nZend\\Http\\Client\n was also designed specifically to handle several consecutive\nrequests with the same object. This is useful in cases where a script requires\ndata to be fetched from several places, or when accessing a specific HTTP\nresource requires logging in and obtaining a session cookie, for example.\n\n\nWhen performing several requests to the same host, it is highly recommended to\nenable the 'keepalive' configuration flag. This way, if the server supports\nkeep-alive connections, the connection to the server will only be closed once\nall requests are done and the \nClient\n object is destroyed. This prevents the\noverhead of opening and closing TCP connections to the server.\n\n\nWhen you perform several requests with the same client, but want to make sure\nall the request-specific parameters are cleared, you should use the\n\nresetParameters()\n method. This ensures that GET and POST parameters, request\nbody, and request headers are reset and are not reused in the next request.\n\n\n\n\nResetting parameters\n\n\nNote that cookies are not reset by default when the \nresetParameters()\n\nmethod is used. To clean all cookies as well, use \nresetParameters(true)\n, or\ncall \nclearCookies()\n after calling \nresetParameters()\n.\n\n\n\n\nAnother feature designed specifically for consecutive requests is the\n\nZend\\Http\\Cookies\n object.  This \"Cookie Jar\" allow you to save cookies set by\nthe server in a request, and send them back on consecutive requests\ntransparently. This allows, for example, going through an authentication\nrequest before sending the actual data-fetching request.\n\n\nIf your application requires one authentication request per user, and\nconsecutive requests might be performed in more than one script in your\napplication, it might be a good idea to store the \nCookies\n object in the user's\nsession. This way, you will only need to authenticate the user once every\nsession.\n\n\nPerforming consecutive requests with one client\n\n\nuse Zend\\Http\\Client;\nuse Zend\\Http\\Cookies;\n\n// First, instantiate the client\n$client = new Client(\n    'http://www.example.com/fetchdata.php',\n    ['keepalive' => true]\n);\n\n// Do we have the cookies stored in our session?\nif (isset($_SESSION['cookiejar'])\n    && $_SESSION['cookiejar'] instanceof Cookies\n) {\n    $cookieJar = $_SESSION['cookiejar'];\n} else {\n    // If we don't, authenticate and store cookies\n    $client->setUri('http://www.example.com/login.php');\n    $client->setParameterPost([\n        'user' => 'shahar',\n        'pass' => 'somesecret',\n    ]);\n    $response = $client->setMethod('POST')->send();\n    $cookieJar = Cookies::fromResponse($response);\n\n    // Now, clear parameters and set the URI to the original one\n    // (note that the cookies that were set by the server are now\n    // stored in the jar)\n    $client->resetParameters();\n    $client->setUri('http://www.example.com/fetchdata.php');\n}\n\n// Add the cookies to the new request\n$client->setCookies($cookieJar->getMatchingCookies($client->getUri()));\n$response = $client->setMethod('GET')->send();\n\n// Store cookies in session, for next page\n$_SESSION['cookiejar'] = $cookieJar;\n\n\n\nData streaming\n\n\nBy default, \nZend\\Http\\Client\n accepts and returns data as PHP strings.\nHowever, in many cases there are big files to be received, thus keeping them in\nmemory might be unnecessary or too expensive. For these cases,\n\nZend\\Http\\Client\n supports writing data to files (streams).\n\n\nIn order to receive data from the server as stream, use \nsetStream()\n. The\nsingle, optional argument specifies the filename where the data will be stored.\nIf the argument is just \nTRUE\n (default), a temporary file will be used and\nwill be deleted once the response object is destroyed. Setting the argument to\n\nFALSE\n disables the streaming functionality.\n\n\nWhen using streaming, the \nsend()\n method will return an object of class\n\nZend\\Http\\Response\\Stream\n, which has two useful methods: \ngetStreamName()\n\nwill return the name of the file where the response is stored, and\n\ngetStream()\n will return stream from which the response could be read.\n\n\nYou can either write the response to pre-defined file, or use temporary file\nfor storing it and send it out or write it to another file using regular stream\nfunctions.\n\n\n$client->setStream(); // will use temp file\n$response = $client->send();\n\n// copy file:\ncopy($response->getStreamName(), 'my/downloads/file');\n\n// use stream:\n$fp = fopen('my/downloads/file2', 'w');\nstream_copy_to_stream($response->getStream(), $fp);\n\n// write to an existing file:\n$client->setStream('my/downloads/myfile')->send();",
            "title": "Advanced"
        },
        {
            "location": "/client/advanced/#http-client-advanced-usage",
            "text": "",
            "title": "HTTP Client Advanced Usage"
        },
        {
            "location": "/client/advanced/#http-redirections",
            "text": "Zend\\Http\\Client  automatically handles HTTP redirections, and by default\nwill follow up to 5 redirections. This can be changed by setting the maxredirects  configuration parameter.  According to the HTTP/1.1 RFC, HTTP 301 and 302 responses should be treated by\nthe client by resending the same request to the specified location, using the\nsame request method. However, most clients to not implement this and always use\na  GET  request when redirecting. By default,  Zend\\Http\\Client  does the same;\nwhen redirecting on a 301 or 302 response, all query and body parameters are\nreset, and a  GET  request is sent to the new location. This behavior can be\nchanged by setting the  strictredirects  configuration parameter to boolean TRUE :  // Strict Redirections\n$client->setOptions(['strictredirects' => true]);\n\n// Non-strict Redirections\n$client->setOptions(['strictredirects' => false]);  You can always get the number of redirections done after sending a request\nusing the  getRedirectionsCount()  method.",
            "title": "HTTP redirections"
        },
        {
            "location": "/client/advanced/#adding-cookies-and-using-cookie-persistence",
            "text": "Zend\\Http\\Client  provides an interface for adding cookies to your request, so\nthat no direct header modification is required. Cookies can be added using\neither the addCookie() or  setCookies()  method.  addCookie()  can accept\neither a name and value, a  SetCookie  header instance, or an array of SetCookie  header instances.  use Zend\\Http\\Header\\SetCookie;\n\n// Basic usage: provide a cookie name and cookie value:\n$client->addCookie('flavor', 'chocolate chips');\n\n// Or provide a SetCookie instance:\n$cookie = SetCookie::fromString('Set-Cookie: flavor=chocolate%20chips');\n$client->addCookie($cookie);\n\n// Multiple cookies can be set at once by providing an\n// array of SetCookie instances:\n$cookies = [\n    SetCookie::fromString('Set-Cookie: flavorOne=chocolate%20chips'),\n    SetCookie::fromString('Set-Cookie: flavorTwo=vanilla'),\n];\n$client->addCookie($cookies);  The  setCookies()  method works in a similar manner, except that it requires an\narray of cookie name/value pairs as its only argument, and also clears the\ncookie container before adding the new cookies:  // setCookies accepts an array of cookie values as $name => $value\n$client->setCookies([\n    'flavor' => 'chocolate chips',\n    'amount' => 10,\n]);  See the  Headers documentation  for more detail on the SetCookie  class.",
            "title": "Adding cookies and using cookie persistence"
        },
        {
            "location": "/client/advanced/#enabling-cookie-stickiness",
            "text": "Zend\\Http\\Client  also provides a means for simplifying cookie \"stickiness\"\n\u2014 i.e., having the client internally store all sent and received cookies,\nand resending them on subsequent requests. \u2014 via the  Zend\\Http\\Cookies \nclass. This is useful when you need to log in to a remote site first and\nreceive an authentication or session ID cookie before sending further requests.  $headers = $client->getRequest()->getHeaders();\n$cookies = new Zend\\Http\\Cookies($headers);\n\n// First request: log in and start a session\n$client->setUri('http://example.com/login.php');\n$client->setParameterPost(['user' => 'h4x0r', 'password' => 'l33t']);\n$client->setMethod('POST');\n\n$response = $client->getResponse();\n$cookies->addCookiesFromResponse($response, $client->getUri());\n\n// Now we can send our next request\n$client->setUri('http://example.com/read_member_news.php');\n$client->setCookies($cookies->getMatchingCookies($client->getUri()));\n$client->setMethod('GET');  See the chapter on  cookies  for more detail.",
            "title": "Enabling Cookie Stickiness"
        },
        {
            "location": "/client/advanced/#setting-custom-request-headers",
            "text": "Setting custom headers is performed by first fetching the header container from\nthe client's  Zend\\Http\\Request  instance. This  Headers  container offers a\nnumber of methods for setting headers:  use Zend\\Http\\Header;\n\n// Fetch the container\n$headers = $client->getRequest()->getHeaders();\n\n// Setting a single header using a name and value. Will not overwrite any //\npreviously-added headers of the same name.\n$headers->addHeaderLine('Host', 'www.example.com');\n\n// You can also use a full header line:\n$headers->addHeaderLine('Host: www.example.com');\n\n// Sometimes you may want to use a HeaderInterface instance:\n$headers->addHeader(Header\\Host::fromString('Host: www.example.com'));\n\n// You can also add multiple headers at once by passing an\n// array to addHeaders() using any of the formats below:\n$headers->addHeaders([\n    // Zend\\Http\\Header\\* instance:\n    Header\\Host::fromString('Host: www.example.com'),\n\n    // Header name/value pair:\n    'Cookie' => 'PHPSESSID=1234567890abcdef1234567890abcdef',\n\n    // Raw header string:\n    'Cookie: language=he',\n]);  Zend\\Http\\Client  also provides a convenience method for setting request\nheaders,  setHeaders() .  This method will create a new header container, add\nthe specified headers, and then store the new header container in its Zend\\Http\\Request  instance. As a consequence, any pre-existing headers will\nbe erased:  use Zend\\Http\\Header;\n\n// Setting multiple headers via the client; removes all existing headers,\n// replacing the request header container with the following:\n$client->setHeaders([\n    Zend\\Http\\Header\\Host::fromString('Host: www.example.com'),\n    ['Accept-Encoding' => 'gzip,deflate'],\n    'X-Powered-By: Zend Framework',\n]);",
            "title": "Setting custom request headers"
        },
        {
            "location": "/client/advanced/#file-uploads",
            "text": "You can upload files through HTTP using the  setFileUpload()  method. This\nmethod takes a file name as the first parameter, a form name as the second\nparameter, and data as a third optional parameter. If the third data parameter\nis  NULL , the first file name parameter is considered to be a real file on\ndisk, and  Zend\\Http\\Client  will try to read this file and upload it. If the\ndata parameter is not  NULL , the first file name parameter will be sent as the\nfile name, but no actual file needs to exist on the disk. The second form name\nparameter is always required, and is equivalent to the \"name\" attribute of an <input>  tag, if the file was to be uploaded through an HTML form. A fourth\noptional parameter provides the file's  Content-Type . If not specified, and Zend\\Http\\Client  reads the file from the disk, the  mime_content_type() \nfunction will be used to guess the file's content type, if it is available. In\nany case, the default MIME type will be  application/octet-stream .  // Uploading arbitrary data as a file:\n$text = 'this is some plain text';\n$client->setFileUpload('some_text.txt', 'upload', $text, 'text/plain');\n\n// Uploading an existing file:\n$client->setFileUpload('/tmp/Backup.tar.gz', 'bufile');\n\n// Send the files:\n$client->setMethod('POST');\n$client->send();  In the first example, the  $text  variable is uploaded and will be available as $_FILES['upload']  on the server side. In the second example, the existing\nfile  /tmp/Backup.tar.gz  is uploaded to the server and will be available as $_FILES['bufile'] . The content type will be guessed automatically if\npossible, defaulting to  application/octet-stream .",
            "title": "File uploads"
        },
        {
            "location": "/client/advanced/#uploading-files",
            "text": "When uploading files, the HTTP request  Content-Type  is automatically set to multipart/form-data .  Keep in mind that you must send a POST or PUT request\nin order to upload files; most servers will ignore the request body on other\nrequest methods.",
            "title": "Uploading files"
        },
        {
            "location": "/client/advanced/#sending-raw-post-data",
            "text": "You can send raw POST data via  Zend\\Http\\Client  using the  setRawBody() \nmethod. This method takes one parameter: the data to send in the request body.\nWhen sending raw POST data, it is advisable to also set the encoding type using setEncType() .  $xml = '<book>'\n    . '  <title>Islands in the Stream</title>'\n    . '  <author>Ernest Hemingway</author>'\n    . '  <year>1970</year>'\n    . '</book>';\n$client->setMethod('POST');\n$client->setRawBody($xml);\n$client->setEncType('text/xml');\n$client->send();  The data should be available on the server side through PHP's  php://input \nstream.",
            "title": "Sending raw POST data"
        },
        {
            "location": "/client/advanced/#raw-post-data-overrides-other-content",
            "text": "Setting raw POST data for a request will override any POST parameters or file\nuploads; you should not try to use both on the same request. Keep in mind\nthat most servers will ignore the request body unless you send a POST\nrequest.",
            "title": "Raw POST data overrides other content"
        },
        {
            "location": "/client/advanced/#http-authentication",
            "text": "Currently,  Zend\\Http\\Client  only supports basic HTTP authentication. This feature is utilized\nusing the  setAuth()  method, or by specifying a username and a password in the URI. The  setAuth() \nmethod takes 3 parameters: the user name, the password and an optional authentication type\nparameter.  use Zend\\Http\\Client;\n\n// Using basic authentication\n$client->setAuth('shahar', 'myPassword!', Client::AUTH_BASIC);\n\n// Since basic auth is default, you can just do this:\n$client->setAuth('shahar', 'myPassword!');\n\n// You can also specify username and password in the URI\n$client->setUri('http://christer:secret@example.com');",
            "title": "HTTP authentication"
        },
        {
            "location": "/client/advanced/#sending-multiple-requests-with-the-same-client",
            "text": "Zend\\Http\\Client  was also designed specifically to handle several consecutive\nrequests with the same object. This is useful in cases where a script requires\ndata to be fetched from several places, or when accessing a specific HTTP\nresource requires logging in and obtaining a session cookie, for example.  When performing several requests to the same host, it is highly recommended to\nenable the 'keepalive' configuration flag. This way, if the server supports\nkeep-alive connections, the connection to the server will only be closed once\nall requests are done and the  Client  object is destroyed. This prevents the\noverhead of opening and closing TCP connections to the server.  When you perform several requests with the same client, but want to make sure\nall the request-specific parameters are cleared, you should use the resetParameters()  method. This ensures that GET and POST parameters, request\nbody, and request headers are reset and are not reused in the next request.",
            "title": "Sending multiple requests with the same client"
        },
        {
            "location": "/client/advanced/#resetting-parameters",
            "text": "Note that cookies are not reset by default when the  resetParameters() \nmethod is used. To clean all cookies as well, use  resetParameters(true) , or\ncall  clearCookies()  after calling  resetParameters() .   Another feature designed specifically for consecutive requests is the Zend\\Http\\Cookies  object.  This \"Cookie Jar\" allow you to save cookies set by\nthe server in a request, and send them back on consecutive requests\ntransparently. This allows, for example, going through an authentication\nrequest before sending the actual data-fetching request.  If your application requires one authentication request per user, and\nconsecutive requests might be performed in more than one script in your\napplication, it might be a good idea to store the  Cookies  object in the user's\nsession. This way, you will only need to authenticate the user once every\nsession.",
            "title": "Resetting parameters"
        },
        {
            "location": "/client/advanced/#performing-consecutive-requests-with-one-client",
            "text": "use Zend\\Http\\Client;\nuse Zend\\Http\\Cookies;\n\n// First, instantiate the client\n$client = new Client(\n    'http://www.example.com/fetchdata.php',\n    ['keepalive' => true]\n);\n\n// Do we have the cookies stored in our session?\nif (isset($_SESSION['cookiejar'])\n    && $_SESSION['cookiejar'] instanceof Cookies\n) {\n    $cookieJar = $_SESSION['cookiejar'];\n} else {\n    // If we don't, authenticate and store cookies\n    $client->setUri('http://www.example.com/login.php');\n    $client->setParameterPost([\n        'user' => 'shahar',\n        'pass' => 'somesecret',\n    ]);\n    $response = $client->setMethod('POST')->send();\n    $cookieJar = Cookies::fromResponse($response);\n\n    // Now, clear parameters and set the URI to the original one\n    // (note that the cookies that were set by the server are now\n    // stored in the jar)\n    $client->resetParameters();\n    $client->setUri('http://www.example.com/fetchdata.php');\n}\n\n// Add the cookies to the new request\n$client->setCookies($cookieJar->getMatchingCookies($client->getUri()));\n$response = $client->setMethod('GET')->send();\n\n// Store cookies in session, for next page\n$_SESSION['cookiejar'] = $cookieJar;",
            "title": "Performing consecutive requests with one client"
        },
        {
            "location": "/client/advanced/#data-streaming",
            "text": "By default,  Zend\\Http\\Client  accepts and returns data as PHP strings.\nHowever, in many cases there are big files to be received, thus keeping them in\nmemory might be unnecessary or too expensive. For these cases, Zend\\Http\\Client  supports writing data to files (streams).  In order to receive data from the server as stream, use  setStream() . The\nsingle, optional argument specifies the filename where the data will be stored.\nIf the argument is just  TRUE  (default), a temporary file will be used and\nwill be deleted once the response object is destroyed. Setting the argument to FALSE  disables the streaming functionality.  When using streaming, the  send()  method will return an object of class Zend\\Http\\Response\\Stream , which has two useful methods:  getStreamName() \nwill return the name of the file where the response is stored, and getStream()  will return stream from which the response could be read.  You can either write the response to pre-defined file, or use temporary file\nfor storing it and send it out or write it to another file using regular stream\nfunctions.  $client->setStream(); // will use temp file\n$response = $client->send();\n\n// copy file:\ncopy($response->getStreamName(), 'my/downloads/file');\n\n// use stream:\n$fp = fopen('my/downloads/file2', 'w');\nstream_copy_to_stream($response->getStream(), $fp);\n\n// write to an existing file:\n$client->setStream('my/downloads/myfile')->send();",
            "title": "Data streaming"
        }
    ]
}